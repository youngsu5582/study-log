OOP 를 잘 한다는 것. 제작자가 아닌 사용자를 고려한 코드를 만든다는 것

## 1. 객체, 클래스, 인스턴스
### 객체란 무엇인가?

- OOP 환경에서 소프트웨어를 구성하는 단위 요소
- 변수 및 그와 관련된 메소드가 모여서 이뤄진 하나의 집합체
  -> 그렇기에, 클래스는 반드시 존재 이유와 목적이 명확해야 한다

- Java 에서는 클래스를 객체로 기술

설계라는 건 결국 논쟁거리다. 객체를 쪼갠다던가, 구성을 어떻게 한다던가 등은 사람마다 다를 수 있다.

하지만, 정답이 없다.
오히려, 초짜일 때 객체지향을 배우는건 독이될 수 있다.
모든걸 객체로 쪼개고 나누면? 그럴꺼면 왜 객체를 나누지? 라는 생각이 자연스럽게 다가온다.

기존, 절차적 방식의 프로그래밍 기법은 CPU 라는 기계 장치의 Operation Code 를 순차적으로 수행해나가는 것
-> 기계적 특성에 맞게 작성해준 일환의 프로그래밍

> 애초에 하드웨어 세상에선 객체란게 없다.
> 함수와 Stack 정도..?

### 항, 식, 구문

![](https://i.imgur.com/x9tAikr.png)


이런 항, 식 그리고 구문들이 합쳐져서?

![500](https://i.imgur.com/EYDYnfI.png)

메소드가 만들어지고..
메소드가 모여 클래스가 탄생되고..
클래스들이 모여서 패키지로 응집이 된다. ( 넘어가면, 모듈 그리고 프로젝트 )

더 들어가자면, 관계가 생길것이다. ( A 가 B 를 호출한다던가.. -> 의존관계 )

### 클래스, 객체, 인스턴스

- 객체 라는 용어는 추상적이고, 단위적 <-> 클래스는 언어의 문법
    - 클래스는 객체를 기술하는 문법
    - 클래스 형식에 대해 선언 할 수 있는 것은 참조

- 변수 대신 인스턴스라고 표현

> 인스턴스화 : 설계도에 따라 건물을 만든다

## 2. 클래스 기본 문법과 두 가지 관점

구성요소(변수, 함수) 를 멤버라 지칭
- 변수는 필드, 함수는 메서드
- 변수는 메모리를 사용하는 보편적 수단

```java
class Calculator {
	...
}
```

선언과 정의가 공존하는 구조 (C언어에선 선언과 정의가 분리되어 있다)
- `int a` : 선언, `a = 10;` : 정의, `int a = 10;` : 선언과 정의

객체 작성자와 사용자를 구분해 생각하는 능력은 필수적이다.
- 메서드를 호출하는 쪽이 사용자
- 메소드를 작성하는 쪽이 작성자

-> 항상, 사용자를 배려해줘야 한다.

> 물론, 대부분의 코드는 우리가 작성자 & 사용자를 같이 작성할 것이다.
> 그럼에도 끊임없이 고민해서 작성해야 한다. 6개월 후의 우리 자신, 다른 팀원분들을 위해서

### 클래스 기본 구성

클래스는 아래와 같이 이루어져 있다.

![500](https://i.imgur.com/9FTJDTM.png)

- 생성자
- 메소드
- 필드

클래스는 패키지에 속한다. 디스크 상 존재할 때는 폴더 구조로 존재한다.

### 기본 문법

- 클래스 이름은 영문으로 작성 + 첫 글자는 대문자 표기가 보편적 규칙
- 클래스 이름과 지정되는 `.java` 파일명이 같아야 함
    - 대소문자 구분
    - public 선언 시 필수적
    - 특정 .java 파일안에 여러 클래스 함께 정의해도 별도 파일로 저장 X - 내부 클래스

## 3. 생성자와 필드 초기화

### 멤버 선언 및 초기화

- 필드 선언 시, 초기값 정의 가능
  -> 원시형 값은 JVM 이 기본 값으로 지정, 래퍼 값은 null 로 지정
- 생성자를 통해 초기화 가능
  -> 필드 선언 시 초기값과 생성자에서 정의하는 값이 다르면 `생성자에 기술한 코드가` 우선

- 메소드 내 지역 변수는 JVM 의 Stack 영역을 사용
- 인스턴스를 생성하는 건 JVM 의 Heap 영역을 사용 - `new` 키워드를 사용해 동적 생성

### 접근제어

내부, 외부의 접근을 제외한다는 것

- 외부의 접근을 막고싶다면 private, 외부의 접근을 열고싶다면 public

> 일단, 변수는 private 으로 두고 정말정말로 필요하다면 public 으로 열 것
> -> 자연스럽게 getter, setter 가 등장할 것

```java
public static void main(String[] args) {
	MyFirstClass myClass = new MyFirstClass();
}
```

myClass 는 참조자 = Pointer = JVM 상의 메모리 주소 ( Heap 영역 어딘가 )

### 생성자

- 객체가 생성되는 시점에 자동으로 호출 되는 메소드
- 이름은 클래스 이름과 동일 ( 반환자 & 호출자가 없음 )
- 다중 정의 가능

클래스 자체와 관련된 코드만 기술해야 한다!

```java
class Calculator {

	private int value = 10;
	
	Calculator() {
		value = 25;
	}
}
```

`Calculator` 는 기본 생성자 - 생략해도 JVM 이 자동으로 생성한다 ( 생성자가 하나도 없다면 )

```java
private Calculator() {
	...
}
```

와는 당연히 외부에선 해당 생성자 접근 불가능

### 인스턴스 생성

- `new` 키워드 연산에 따른 동적 생성
- 클래스 형식에 대한 변수 선언은 모두 참조 형태 - 인스턴스 존재하지 않는 경우는 null
- 인스턴스에 대해 여러 참조자 존재 가능
  -> 필연적으로 사이드 이펙트를 부를 수 있음

## 4. 클래스 멤버에 대한 접근 제어

- public : 외부접근 허용
- protected : 외부접근 차단 - 같은 패키지, 파생 클래스 접근은 허용
- default : 같은 패키지 소속 클래스만 접근 허용
- private : 외부접근 차단

> default 는 솔직히 잘 사용하지 않는 것 같다.

클래스, 메서드, 필드에 제어 가능

### 접근을 제어하는 이유

궁극의 정교함은 간소함이다. 옴니아는 윈도우 용 스마트폰.
Application 이 다운되니 O.S 가 다운되더라.

-> 결과는 어떻게 되었는가

### getter, setter

- 번외 : SW 를 개발할 땐 생산성, 유지보수성을 따지게 된다.
  -> 얼마나 빨리 개발 + 얼마나 빨리 오류를 고칠수 있을지.
  => 그렇기에 결국 프레임워크를 사용하는 것이다.

스프링 프레임워크 및 Jackson 을 사용하려면 반필수적으로 선언해줘야 하는 메소드

- 감춰진 필드에 대해 외부에서 접근 할 수 있도록 허용된 메소드
- 필드에 대한 읽기, 쓰기 접근을 분리해 통제 가능
  -> CallStack 에 포함되므로 (메소드니까) , 추적하기 매우 용이해진다

=> 항상 객체를 제작하는 관점과 사용하는 관점 두 가지를 분리해 생각해야 한다

## 5. this

> 참조자 : Pointer 와 거의 유사한 키워드

### this

- 클래스로 구현한 객체 자신의 인스턴스에 대한 참조자
- 클래스 (현재 코드) 에 대한 인스턴스(미래, 외부) 선언 시 값이 결정될 수 있음
  -> 메모리 어디에 쓰이는지는 JVM 만이 안다. 어디엔가 저장되는 그 값을 기술한게 this

- 같은 클래스에 대한 인스턴스라 하더라도 this 값은 각자 다른 값이 된다 - 덮어지면 큰일남 ㅋㅋ
- 메소드 호출 시, 스택(0번 슬롯)에 값이 저장 - JVM 이 알아서 넣어줌
- 정적 메소드에서는 사용 할 수 없음 - 당연하다 ㅇ.ㅇ

```java
private int data = 5;

void setData() {
	int data = 3;
	System.out.println(this.data + data); // 8
}

// 가능은 하다...
static void setData(Test data, int param) {
	data.data = param;
}
```

### User mode process JVM

유저 모드에서 돌아가는 프로세스

- 빅 엔디안 기반 시스템 (Stack, Heap Area, Method Area)
- 가상 메모리 기반 처리

## 6,7. 실습은 생략
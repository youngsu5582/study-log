
## 기본 이론

`class child extends parent`

- 객체단위 코드를 재사용하는 문법
- `is-a, has-a` 관계로 설명 가능
- 부모/자식 클래스, 기본/파생 클래스등으로 구분
- 다중 상속자 허용 X - C++ 과 다름
- 모든 클래스는 기본적으로 Object 의 파생형식

- 파생 클래스 생성 시, 기본 클래스도 함께 생성(생성자 호출)
- 파생 클래스는 기본 클래스 멤버에 접근 가능 - 접근제어 지시자에 따라 제어
- 파생 클레스에서 기본 클래스의 메소드 재정의 가능 - 오버라이딩
- 상속관계 적용될 경우 코드 흐름이 2차원적 구조를 갖게 되어 감춰지는 경향 발생

> 미래, 과거가 생기게 된다.
> 현재 개발자와 미래 개발자가 상호 소통이 가능하게 된다.

## 상속과 생성자

파생 클래스가 생성되면? 내부적으론 상속 클래스도 같이 내부에 가지고 있는다.
먼저 상속 클래스의 생성자 실행 -> 파생 클래스의 생성자 실행

- 파생 클래스 생성자는 가장 먼저 호출되지만, 가장 나중에 실행
- 재귀호출과 비슷하게 생성자 함수에 대한 호출 스택이 쌓여 올라가는 것이 특징
- 파생 클래스에서 기본 클래스 필드 정의는 적절하지 않은 경우가 대부분

> 사실상 죄악.. 외부가 내부를 인지하고 건든다는 것

> 메소드 protected 까지가 최선, 변수는 무조건 private 으로 할 것

### 상속을 배우는 시간부터 알아야만 하는 시간차

- 부모 클래스와 파생 클래스가 정의되는 시점
    - 부모 클래스 기준 '현재'는 파생 클래스가 '미래'에 정의되는 걸 확정
    - 6개월 후 미래의 내가 오늘 이 클래스에 대해 얼마나 기억할 수 있을 것인가.
- 이해도 부족에 따른 문제
    - 상속에 상속은 바람직하지 않다.
    - 증조 할아버지를 기억하는가..?

> 처음에는 protected 로 시작하고, 나중에 필요에 따라 public 으로 변경하자
> 변경 및 확장의 가능성이 생긴다면 미리 미래의 개발자와 대화를 할 수 있게

>결국 상속을 안티패턴이라고 하는 건, 상속의 상속이 이뤄질 수 있기 때문이다.
>자기가 코드 조금 수정했다고 한게, 어디까지 수정될 지 알 수 없어진다.

- 미래의 파생 클래스를 고려해 현재 클래스 코드를 작성해야한다. ⭐

## 부모 클래스 생성자 선택

- 파생 클래스 생성자에서 부모 클래스의 여러 생성자 중 원하는 것이 호출되게 강제화
- `super();`

```java
public Ex(int param) {
	super(param);
	sout("Ex(int)");
}
```

직접 지정하자 ㅇ.ㅇ

## 메소드 재정의

- 파생 클래스에서 기본 클래스 메서드 재정의(Override) 가능 - `@Override`
- 기본 클래스 메소드를 재정의 하는 건, `기존 메소드를 대체`하거나 `코드를 추가하는 목적` 을 의미한다
- 메서드 재정의 시 실제 인스턴스 형식이 우선시 된다 - 파생 클래스의 메소드가 실행
- final 선언으로 파생 클래스에서 메서드 재정의 하지 못하게 차단도 가능

## 불필요한 호출로 미래와 대화하기

- 부모 클래스에서 정한 함수 호출 관계로 파생 클래스에서 재정의된 메소드가 호출 될 수 있음
- 구조가 정한 흐름을 확장해 나가, 내 코드를 추가하는 방식으로 올라탈 수 있음
    - Called by framework
    - onXXX () 메소드

현재 시점에선, 불필요한 메소드를 만든다. 그리고, 이 메소드를 호출한다.

어떤 함수가, 미래에는 재정의 될 수 있다!!
-> 현재 시점에 누군가가, 재정의 된 미래의 함수를 불러올 수 있다.

> Spring 역시도, 너가 extends or implements 해서 정의 해놓으면?
> `우리가 그걸 정해진 규칙 안에서 실행해줄게 ㅇ.ㅇ` 이다.

### called by framework ⭐

```java
public void setData(int param) {
	if(onSetData(param)) {
		this.data = param;
	} else {
		this.data = 0;
	}
}

protected boolean onSetData(int param) {
	return true;
}
```

> 이딴 코드르 왜 짜지..? 라고 생각할 수 있다.
> 먼 미래를 보고, 변경할 수 있는 근거를 제시해주는 것
> ( 지금은 무조건 true야, 하지만 미래엔? 이런 조건 검사가 필요할 거 같다. 와 같이 )

```java
@Override
protected boolean onSetData(int param) {
	if(param > 100 || param < 0) {
		return false;
	}
	return true;
}
```

코드를 작성해 대체 가능

=> 보기에 따라 불필요해보이지만, 미래의 코드를 부를 수 있게 해주는게 핵심

## 실습은 생략

## UML

UML(Unified Modeling Language)

클래스는 현업에서 사실상 끝없이 늘어난다.
차악의 코드를 위해서 끝없이 얘기하고 고민한다.
그림으로 도식화 해야, 회의실에서 얘기가 편하게 된다..!
=> 이를 위해 UML 이 필요하다.

> 개발자는 일반적으로 Class, Sequence Diagram 정도만 알면 된다. - Class 가 주

### 클래스 다이어그램

![](https://i.imgur.com/ugdLw9G.png)

`클래스 / 필드 / 메소드` 로 구성되어 있다.

- `+` : public
- `-` : private

![](https://i.imgur.com/jdndyEz.png)

남자 - 군인의 관계라면?

- 일반화 : 군인 -> 남자
- 구체화,실체화 : 남자 - - - - > 군인

상속은 일반적으로 의존 관계 역시도 포함된다.

![400](https://i.imgur.com/c86eiXw.png)

MyUI 는 UserData 를 의존하고 있다.
어떤 클래스가, 제 3의 클래스에서 생성되거나, 호출되거나 등등이라면 의존성이 높다! 라고 할 수 있는것

![500](https://i.imgur.com/tFW5ZRI.png)

MyList 가 항상 UserData 를 가지는건 아니지만, 가지고 있다.

`*` : N개 라는 의미

### 시퀸스 다이어그램

![700](https://i.imgur.com/kXbOmLU.png)

자주 사용하진 않는다.

## 알아두면 좋을 동적 바인딩

- 함수와 함수가 서로 `호출 - 피호출` 관계가 되는것이 '바인딩'
- 바인딩 시점이 Compile-time 이면 Static binding
- 바인딩 시점이 Run-time 이면 Dynamic binding ( Lately Binding )

사실, JVM 이 알아서 다 해준다.

### C++ 가상 함수 테이블 ( vtable )

- vtable 은 클래스 멤버 함수 중 가상화 된 함수들에 대한 포인터의 배열
- 가상 함수는 함수 포인터 배열을 참조해 호출할 함수 결정 - Dynamic Binding
- 상속관계일 때 vtable 의 값은 파생 클래스 생성자가 호출되는 시점에 업데이트 되는 것이 특징

> 내용이 어렵다... 그냥, 자바의 일반적인 메소드가 가상 함수이다.

인스턴스가 생성되면 함수 포인터 배열이 생성된다.
(0번은 생성자, 1번은 메소드 등등등..)

이 배열의 요소는 실제 실행해야 하는 코드가 위치해있는 주소를 가르킨다.
상속 관계일 때는, 부모 클래스의 메소드를 먼저 가르키고? -> 파생 클래스가 생성 될 때 다시 'overwrite' 한다.

결국..? 오버라이딩 처럼, 실제 객체 타입이 뭔지에 따라 결정되는 동적이 아니라면
정적 바인딩인거 같음.

```
- invokestatic
  - 대상: static 메서드
  - 바인딩: 정적(컴파일 시점에 대상이 확정)
  - 스택에서 this를 안 꺼냄(인스턴스가 없으니)

- invokespecial
  - 대상:
	  1. 생성자(<init>)
	  2. private 메서드
	  3. super 호출(오버라이드된 메서드를 부모 구현으로 직접 호출)
  - 바인딩: 정적(컴파일 시점 확정)
  - 특징: “특별한” 호출이라 동적 디스패치가 없다.

- invokevirtual
  - 대상: 일반 인스턴스 메서드(클래스의 가상 메서드)
  - 바인딩: 동적(런타임에 실제 객체 타입을 보고 vtable로 구현 선택)
  - 오버라이딩된 메서드 호출이 여기에 해당.

- invokeinterface
  - 대상: 인터페이스에 선언된 메서드 호출
  - 바인딩: 동적(런타임에 실제 객체 타입을 보고 itable 탐색)
  - 실제 구현 클래스에서 어떤 메서드를 제공하는지 런타임에 결정.

- invokedynamic
  - 대상: 런타임에 부트스트랩 메서드로 호출 대상/형태를 결정하는 동적 호출
  - 주로 람다, 동적 언어 런타임 구현 등에 사용
```
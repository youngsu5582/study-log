---
tags:
  - topic/java
  - type/lecture
moc: Java
sub-topic: Clean Code
description: 코드 품질을 저하시키는 대표적인 안티패턴과 개선 방안에 대한 실제 사례 연구
status: in-progress
modified: 2025-12-01T23:51:28+09:00
---

## 1. 생성자 다중 정의

- 일반 메소드와 같이 생성자도 매개변수 구성이 다른 생성자를 여러개 정의할 수 있다.
- 여러 개가 다중 정의되어도 new 연산 시 호출되는 생성자는 1개
- 생성자에서 다른 생성자 호출도 가능 - 호출하려면, 가장 먼저 호출해야 함

## 2. 실습은 생략

## 3. 깊은 복사와 얖은 복사 ⭐️

### 얕은 복사

- Shallow Copy
- 참조의 대상을 복사해서 늘리는게 아닌, 참조자만 늘리는 형태
-> 사이드 이팩트 발생의 원인

```java
Test a = new Test();
Test b = a;
```

a = b

소위 언제 바보짓을 하게 되는가.

```java
public void processData(MyData data) {
	data.setData("Processed" + data.getData());
}

MyData data = new MyData(5);
processData(data);
```

`MyData data` 는 참조자를 의미한다.
-> 즉, 메소드 실행시 Call By Reference 가 일어난다.

```java
class Address {
	String address;
	String phone;
}

class User {
	private String name;
	private Address address;
	
	User(String name, String address, String phone) {
		this.name = name;
		this.address = new Address(address, phone);
	}
	
	public void copy(User user) {
		this.name = name;
		this.address = user.address;
	}
}
```

User 를 그대로 가져와서 복사한다.
Address 가 얕은 복사로 처리 된다.

```java
user1.copy(user2);
var address = user2.getAddress();
address.setPhone("010-3333-3333");
address.setAddress("Buson");

System.out.println(user1.getAddress().getPhone());
```

느닷없이 user1 의 address 하위 요소들이 바뀌게 된다..
1과 2는 같은 Address 객체를 참조하므로

### 깊은 복사

- 원본 자체도 새로 할당하고 복사하는 방식
- Shallow Copy 와 달리 두 개의 원본, 두 개의 참조가 각각 별도로 존재
- 사이드 이펙트 오류 가능성이 없음
- 참조를 멤버로 가지며, 인스턴스를 동적 할당하는 경우에는 복사 생성자를 구현하자 - clone


## 4. 복사 생성자 - ⭐️

```java
public MyData(MyData rhs) {
}
```

깊은 복사를 하기 위해서

- 객체의 사본을 생성할 때 사용하기 적절한 생성자 함수 - C++ 스타일 문법
- `rhs` 는 Right Hand Side 의 약어이며, 복사의 원본 인스턴스에 대한 참조
- clone 메소드를 만들어도 되긴 하나.. 규약에 모호한 부분 + 예외처리가 복잡한 단점 존재


`l-value = r-value`

```java
class CustomArray {
	private int[] array = null; // array 역시도 참조자
	
	public MyTest(int size) {
		array = new int[size];
	}
	
	public MyTest(MyTest rhs) {
		this(rhs.array.length);
		this.deepCopy(rhs);
	}
	
	public void shallowCopy(CustomArray rhs) {
		this.array = rhs.array;
	}
	
	public void deepCopy(CustomArray rhs) {
		for(int i = 0; i < rhs.array.length; i++) {
			array[i] = rhs.array[i];
		}
	}
}
```

얕은복사면, 배열의 주소를 가리킨다.
즉, 배열의 요소를 변경하면? rhs 내부의 요소를 변경하는 것

## 5. 보이지 않는 임시 객체

- 클래스가 함수의 반환 자료형이 될 경우 (이름이 없는) 임시 객체 생성
- String 클래스는 덧셈 연산 시 임시 객체 생성
-> 비효율의 원인

`a = 3 + 4 + 5` 처럼 연산의 결과

> 엄밀히 따지면 Primitive 이므로 객체가 아니니 생성 안되긴 하겠지만, 가정

메모리 어디인가...
`new` 연산자는 무조건 Heap 영역에 저장.
근데, String 은 Runtime 에 Constant Pool 에 저장된다.

## 6. 정적 멤버

- 클래스 인스턴스가 없어도 독립적으로 존재가능
	- 필드 : 모든 인스턴스에서 공유
	- 메서드

인스턴스와 같은 메모리 영역을 사용하지 않는다.
정적으로 따로 떨어져서 존재

- 일반 메소드와 달리 인스턴스 선언 없이 호출 가능
- 메소드 내에서 this 사용 불가능
- 정적 필드를 final 로 선언해 심볼릭성 상수로 활용  - 가독성이 좋게

=> 인스턴스의 메모리와 독립적이며

메소드의 코드는? 인스턴스 별로 틀리지 않다.
(인스턴스가 100개이면, 메소드 코드가 100일 것인가)
-> Runtime Constant Pool 내부 Method Area 에 위치시킨다. ( 정적 메서드이든, 인스턴스의 메서드이든 )



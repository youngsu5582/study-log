## Java 와 C++ 메모리 관리 차이

컴퓨터는 하드웨어, 소프트웨어로 이루어져 있다.

-  CPU 가 Machine
   -> CPU 가 이해할 수 있는 코드? Machine Code

- 시스템 소프트웨어의 가장 대표적인게?
  -> O.S 그리고 O.S 의 알맹이가 커널

- 우리가 만든 소프트웨어가 프로세스로 실행된다

- C/C++ 은 Native 언어의 일종
    - Machine Code 로 변환되어서 실행된다
    - 운영체제에 대해 직접적인 의존성이 발생한다

> 윈도우에서 특수화 개발된 프로그램은 리눅스에서 바로 못 옮길 수 있다.
> (의존성 특화 프로세스는 성능이 저하될 수도 있음)

### JVM? Virtual Machine??

- Virtual Machine 이란

쉽게 설명해서 CPU 를 HW 가 아닌 SW 로 구현하는 것

Java Byte Code 로 되어있으면 JVM ㅇ.ㅇ
SW 로 CPU, RAM, HDD,SDD 등등 구현해놓은 것 (RAM, SDD 는 가상 메모리)

심지어 O.S 가 제공하는 기능들도 들어있다.

컴퓨터 구조론의 총집합체

- JVM

C, C++ 의 가장 주요쟁점은 `가상 메모리를 어떻게 관리하느냐` 이다. Java 는?

아무리 날고 기어도 O.S를 다운시키지 못한다. (JNI 와 같은 특수한 경우는 제외)
보안점 장점도 명확하다. 결국 JVM 내부 범위로 한정되므로

=> Managed Code - Native X, 제조사마다 O.S 별로 다 만들어줘서 제공

### Java, C++ 메모리 관리 차이

메모리 관리체계가 매우 다르다.

- C++
    - 객체에 대한 모든 관리 책임은 개발자에게 있음 - 소유권, 메모리 할당 및 해제 등등
    - 객체 생명주기에 모두 개입하는 구조

- Java
    - 개체 메모리 해제는 전적으로 JVM 의 몫 - 개발자의 소유권도, 책임도 없음

객체를 생성해도, 객체의 메모리 주소는 알 수 없다.
-> JVM 이 필요에 따라 이동
=> JVM 에게 무조건 물어봐야 한다. ( 한번 거치므로, 속도가 느릴수 있다. )

- 문제 발생 시 구조를 알아야 대응이 가능

## JVM 구성요소 정리

크게는 3개로 구성

![](https://i.imgur.com/sLAj80H.png)

- Class loader
- Runtime data area
- Execution engine
  그 외 나머지는, Native 영역과 관련 ( JNI, Native method Library )

> 단연, 가장 중요한건 Runtime Data Area + GC

- 클래스 로더

일반적인 프로세스 시점은 컴파일 타임 -> 링크 타임 -> 런타임 으로 구성되어있는데
자바는 컴파일 타임 / 링크, 실행 타임으로 이루어져 있다.

`링크, 실행` 을 담당해주는게 클래스 로더
코드에서 필요해질때 로딩을 한다.(링크, 실행 포함)

- 절차상 오류가 일어나면, 로딩이 실패 -> 심한경우, 다른 클래스가 작동 못함 -> 운영 이슈랑 연결

- GC 는 사실상 Heap Area 하나만 관리한다.
- Method area 는 Reflection 과 관련

- Stack area + PC Register

이 둘은 스레드와 관련있다. 각자 스레드가 별도로 가지는 영역.

> 멀티 스레드는 일종의 흐름이 동시에 일어나게 해주는 것

JVM 은 스택 베이스 머신으로 구현되어 있음. 대부분

> 왜 대부분? -> JVM 벤더사에 어떻게 구현 했냐에 따라 달라질 수 있는 영역

- Method Area

Reflection 과 관련 있다.

- 메서드가 Method Area 에 호출된다.
- 메서드 내 `Hello` 같은 상수들도 Method Area 내 `Runtime Constant Pool` 위치

문자열 상수를 많이 쓸수록 적재가 많이 된다. - 생각보다, 메모리를 많이 차지하게 할 수도 있음

- Execution engine

- JIT Compiler : 자바의 성능이 좋아지게 된 결정적인 원인

자바는 하이브리드 언어이다. - 컴파일러, 인터프리터 방식 언어 둘다 적절히 섞어 놓음

자바로 프로그래밍을 하면? -> `.java`
`.java` 를 컴파일 하면? -> 바이트코드인 `.class`

`.class` 는 JVM 이 인식하는 코드 ( CPU 는 인식하지 못함 )
=> 이때, 번역을 해주는게 JIT compiler

근데, JIT 가 하다보니??

'자주? 매번 번역되는 코드가 있던디??' 이걸 매번 번역하지말고, 어디에 미리 저장하면 안될까?
까지 JIT 가 해줌

## .class 파일과 바이트 코드 소개


클래스 로더를 직접 만들순 있다. 굳이..? Why?

이런 바이트 코드들을? Portable Execution 파일라고 부른다. (`.exe`,`.dll`,`.class`)

![500](https://i.imgur.com/4U8CHpR.png)

> 신기한 무언가가 있다.

메이저, 마이너 버전이 뭔지
상수 풀 개수가 몇갠지, 필드가 몇갠지, 메소드가 몇갠지, 속성이 몇갠지 등
현재 클래스, 슈퍼 클래스 정보

등등

![500](https://i.imgur.com/3SGo7GS.png)

헬로우 월드 코드를 바이트로 변환한 코드
`CA FE BA BE` 가 magic 에 해당 - 16진수

이런식으로 생겼다.
리버스 엔지니어링을 하는가? 16진수를 직접 보고 하진 않는다.
-> 스트림 데이터를 보는건 미친짓

![500](https://i.imgur.com/eX2t6yq.png)

와 같이 변환된 코드를 분석하는게 일반적
메인 클래스 클릭 후, `보기 - 바이트 코드 표시` 로 바이트 코드 보기 가능

>소스 코드 역추출도 가능 - 디컴파일
>머신 코드 레벨 코드를 보고, 소스를 유추
>(나중에 인공지능, AI 를 통해 더욱 성장하지 않을까..)

JVM 이 CPU 가 이해할 수 있게, 진짜 머신 코드로 변환이 되어야 한다.
Kernel Mode 단 Compiler 가 또 있음 (즉, `.java` -> `.class` 로 한번 + `.class` -> `Native Machine 코드` 로 두번)

그걸 Just-In-Time Compiler 가 해준다.
코드가 자주 수행되면? byte -> 네이티브 머신 코드으로 바꿔놓고 재사용 하는 방식으로 동작한다.
-> JVM 의 성능을 극단적으로 상승시켜준 요소

- 자주 실행되는 부분을 네이티브 코드로 실시간 변환해 성능을 끌어올림
- 가정이 깨지면 JIT 코드를 폐기하고 인터프리터로 다시 롤백도 함

## 클래스 로더

- 이름을 알고 있는 특정 클래스에 대한 정의(Byte stream) 를 가져오는 역활을 수행

'가져오는 역할'?? 네트워크로도 가져올 수 있다!
-> 자바가 정말 뛰어난 확장성을 가지도록 도와주는 것

- 부트스트랩 클래스 로더

JVM 에서 라이브러리로 취급(rt.jar, tools.jar) 되는 것들을 로드

> 핫스팟에서는 C++ 로 구현

- 플랫폼 클래스 로더(기존 확장 클래스 로더)

하드웨어와 애플리케이션 중간 역할을 해주는 요소들이 로드

- 애플리케이션 클래스 로더

`sun.misc.Launcher$AppClassLoader` 를 의미한다고 한다(?)

### 로더 별 담당 모듈

![](https://i.imgur.com/Y6eOajn.png)

> 아래 요소 외에도 어마어마하게 많다.

- Bootstrap
    - `java.base`
    - `java.net`

    - `java.desktop`
    - `java.naming`
    - `java.sctp`
    - `java.logging`

> 밑에 4개는, IDEA 에서 import 구문에 보이지 않아서 따로 분리

- Platform
    - `java.compiler*`
    - `java.corbar*`
    - `java.sql`
    - `java.charset`
    - `java.jsobject`
    - `java.xml.dom`

- Application
    - `jdk.compiler`
    - `jdk.hotspot.agent`
    - `jdk.jartool`
    - `jdk.jcmd`
    - `jdk.jshell`
    - `jdk.pack`

## Java 클래스 로딩


> 자바는 C언어와 다르게 소멸자가 없다. (객체 생명주기를 직접 관리하지 않기 때문에)
> finalize 라는 키워드를 통해 소멸자 및 GC 를 직접적인 제어가 가능하지만
> 절대 이를 통해 제어하지 말것. - 좋은 꼴을 보기 어렵다

- 클래스 로딩 및 링킹 과정이 모두 런타임에 이루어진다
- 실행 성능이 일부 저하될 순 있으나, 높은 확장성 & 유연성을 제공하는 근간

- 인터페이스만 맞으면, Runtime 에 구현 클래스를 결정하지 않을 수 있음 - 필요할 때 변환 및 적용 가능
- 클래스 로더는 실행할 프로그램 코드를 네트워크로 수신하는 것도 가능은 하다!

논리적인 구조 연결만 맞추면, 네트워크 레이어 까지 확장이 가능해진 것

- 해석(Resolution) 단계는 동적 바인딩을 지원할 목적으로 초기화 후 지연될 수 있음 - Lazy
    - 정적 바인딩 : `a를 call 한다` 와 같은 문법이 바이트코드로 변환
    - 동적 바인딩 : 라이브러리 중 특정 요소를 선택해서 동적 로딩, 처음부터 로딩할 필요가 없는 경우

=> O.S, 개발자의 신경 범위가 줄어들게 된다!

아래의 단계로 로딩이 진행된다.

![600](https://i.imgur.com/BVUtO8m.png)

### 1. 클래스 검증


- JVM 명세가 정하는 규칙과 제약을 만족하는지 확인
    - 파일 형식 - `.class`
    - 메타데이터
    - 바이트코드
    - Symbol 참조 - `A 를 import 한다. A 를 먼저 로딩해야 하나?` 등을 결정
- 보안위협에 대한 검증
    - 바이트코드 검증 시 함께 확인

바이트코드로 얼추 확인이 가능

일반적인 경우, `User mode` 에서 개발한 애플리케이션(C++)이 플랫폼어로 직접 번역되어 CPU 에서 실행된다.
-> 운영체제 레벨에 손상을 가할 수 있다. - O.S 손상 및 디스크 손상 등등

자바는? `User mode` 애플리케이션인 JVM 단에만 한정 된다.

### 2. 준비 및 해석

- `java.lang.Class` 인스턴스가 힙 영역에 생성되고 클래스 변수(정적 멤버) 메모리를 0으로 초기화

클래스의 `static` 요소들도 일단은 초기화

> Class 라는 이름을 가진 클래스
> 말장난인가...? 메타데이터를 담고 있다.
> 그래서, klass or clazz 가 나온것 ( class 가 예약어니까 )

- 로드되는 클래스의 인스턴스는 사용하는 단계에서 힙 사용
- final 선언된 변수는 코드에서 정의한 초기값으로 정의 (0이 아닐 수 있음)
  -> `static final` 은 그냥 상수값을 그대로 초기화 한다는 의미

- 생성자 호출 전 상태 - `new 연산 전` (생성도 되기 전)
    - 필드(인스턴스 변수) 초기값은 생성자 호출 시 정의
    - 정적 필드에 초기값 할당

- 해석은 상수 풀의 심벌 참조들을 직접 참조로 대체하는 과정
  -> 단순, 심벌이 아닌 값을 가르키게

### 3. Heap 영역에 객체 생성

`new 연산` 이 이루어진다.

- JVM 은 객체 저장을 위한 메모리 공간을 확보 후 0으로 초기화 - 객체 헤더는 제외

멤버 변수들을 다 초기값으로 초기화한다.

- 객체 초기화를 위한 구성설정 실시
    - 클래스 이름 & 메타 정보 확인 방법
    - 객체에 대한 해시코드
    - GC 세대 나이

객체는 `Metaspace` - `Object header` - `Instance data` 로 구성되어 있다.

메모리 공간을 차지하는 크기는 `Instnace data` 에 Padding 을 추가하고
인스턴스를 설명하기 위한 `Object header` - `Klass word` 에 접근하면?
로딩 과정에서 생성된 메타데이터들인 `Metaspace` 에 참조가 가능해진다.

- 생성자 호출

### 4. 런타임 데이터 영역

![600](https://i.imgur.com/Jk4en38.png)

Stack, PC register, Native method stack 은 스레드 별 독립적으로 관리된다.

PC register : '몇번 라인으로 이동' 등등을 저장해주는 요소
Native method stack : Native 영역하고 연결되어 동작하는 특화된 코드들이 존재하는 영역
-> 장애가 Native 영역에서 날 가능성도 있다.

재귀 호출을 통해, 스택에 순환이 끝도 없이 쌓이면 `StackOverflow`

JVM 에서 Runtime Data Area 는 말그대로 한 덩어리다. 구역을 조금씩 잘라서 사용한다.

JVM 이 가지고 있는 가상 메모리 VMS

> 32bit 애플리케이션이라 가정하면
> 2GB 정도를 할당 받는다. ( O.S 가 절반 사용 )
> 또 O.S 가 그중에서도 사용하는 부분이 있어서 1.7GB ~ 8GB 정도가 최대치다

- 힙이 거의 대부분을 차지한다
  (Java 를 가동할 때 크기 설정이 가능)

#### Method Area

- JVM 이 읽어들인 각종 타입 정보, 상수, 정적 변수 정보가 저장되는 영역
- JIT 컴파일러가 번역한 기계어 코드를 캐싱하기 위한 메모리 공간으로 활용
- Java 8부터는 PermGen 이 아니라 MetaSpace 에 속함
  -> JVM 힙이 아닌, 네이티브 메모리에서 관리하며 크기가 동적으로 달라질 수 있다!

> 기존, 힙 영역에서 관리할 때는 이런 메소드 영역들의 사용량이 확 늘어났다, 줄어드는 등 변동성이 컸다.
> 운영상에 순간적 피크를 대응하기 어려웠기에, 분리 되었다.

#### Runtime Constant Pool

- 클래스 버전, 필드, 메서드, 인터페이스 등등 클래스 파일에 포함된 정보 및 각종 리터럴, 심볼 참조가 저장되는 영역
  문자열 리터럴만 들어가있는게 아니다. '어떤 클래스가 특정 클래스를 참조해서 특정 메소드를 호출한다' 와 같은 심볼도 저장!

- 클래스 로더가 클래스를 로드할 때 상기 정보들을 저장

- 동적으로 운영되며, 런타임에 새로운 상수가 추가될 수 있음

클래스 하나를 로딩하면?
-> 바이트로 변환된 메소드 코드 + 메소드가 작동하기 위해 필요한 상수들을 Method Area 에 넣는다.
-> 필드들은 힙 영역에 넣는다.

클래스가 100개가 넘으면? Method Area 도 많이 차지할 수 있다. (런타임에자바 리플렉션이 적용되며 추가로 더 차지할 수도 있음)

> 무조건 큰 힙 영역이 좋은가?
> 방이 넓으면 평소에는 좋다. 하지만, 청소할 때는 귀찮아진다.
> -> GC 가 힙 메모리가 크면 클수록 느려지기 시작한다.

정말 많은 정보들이 들어간다.

![650](https://i.imgur.com/4wMtIUP.png)

> 클래스 한개를 만들때 책임을 느껴야 하려나...

## 5. JVM 스택 구조

### Stack area

선형 구조로 `Push` & `Pop` 을 통해서 저장 및 제거가 된다
맨 처음 요소는? 전부 다 꺼내야만 꺼낼 수 있다.
-> 불필요한 구조가 아닌, 편리한 구조 (되돌리기)

순서가 뒤바뀐다.


> JVM 은 Register Machine, Stack Machine 중 Stack Machine 에 가깝다

- 지역변수 테이블, 피연산자 스택, 메소드 반환값 등 저장
    - C/C++ 의 Stack 보다 더 복잡한 구조를 가짐
    - static 이 아닌, 클래스 내부 메소드 호출 시 스택의 제일 처음에는 this가 들어간다.

피연산자 스택?
-> 1 + 2 * 3 = `+1*23`

1. 2,3 을 POP
2. `*` 을 POP 하면, `2 * 3 = 6` 을 통해 6이 다시 PUSH
3. 6,1 을 POP
4. `+` 을 POP 하면, `6 + 1 = 7` 을 통해 7이 다시 PUSH
5. 7을 POP 해서 종료



- 보통 지역변수 테이블을 스택으로 지칭
- 지역변수 테이블은 슬롯으로 이루어지며, 기본형 변수 하나가 슬록 한 개(2걔) 사용

32bit 중 8bit 만 사용하더라도, 32bit 전체를 차지

- Java 스택의 크기는 메모리 용량이 아니라 슬롯의 개수
- JVM 이 허용하는 스택 크기를 초과할 경우 StackOverFlowError !

### Stack frame 구조

![500](https://i.imgur.com/rNMCAce.png)

![500](https://i.imgur.com/uYzi1F0.png)

- 지역변수 테이블은 인덱스 방식으로 운영됨
- 한 요소를 슬롯으로 지칭하며, 기본형식 자료 or 참조를 저장
- 0번은 this (포인터)

`this` 와 매개변수로 시작한다.

- 반환 주소 : A 함수가 연산 하다가, B를 호출하면? B가 결과값을 가지고 돌아갈 주소

### Native method stack

- C++ 로 개발된 Native 코드(함수 단위) 가 실행 될 때 지역변수 및 자동변수가 사용하는 스택 메모리
- 구현하기 따라 JVM stack 과 합쳐서 사용하기도 함

## JVM 힙 영역과 GC

new 로 만들어진 객체는 GC 가 알아서 해준다.

### JVM Heap 영역

- GC 가 관리하는 메모리 영역으로, Java 에서 사용되는 객체의 인스턴스 및 배열이 저장되는 공간
- Java 에서 사용되는 객체의 인스턴스 및 배열이 저장되는 공간
- 설정에 따라 크기 변경하거나 고정할 수 있음
    - 부족시 OutOfMemoryError 오류 발생
    - Heap dump, Call stack 을 보고 파악 해야함
- 세대별 컬렉션 이론을 기반으로 설계 및 운영
    - Eden, Survivor
    - New(Young)/Old generation
    - 영구 세대(Metaspace)

### JVM Garbage collector

- Heap 영역에서 참조되지 않는 개체를 수집 및 제거해 메모리 회수

함수가 끝나면, 스택에서 지역 변수가 POP 된다.
-> 참조자가 사라지므로, 참조되지 않은 객체로 JVM 이 인식할 수 있다.

- Minir/Major(Full) GC
    - GC 수행 시 프로그램 일시 정지
    - -stop-the-world

JVM 이 일시정지..!

- GC 속도
    - Minir GC 가 보통 1초 이내 완료
    - Full GC 가 수 초 이상 진행되고 하며, 이 지연 때문에 DB 연결이 끊기는 등 운영문제가 발생할 수 있음

### GC 기술의 시작

- Java 에서 (사실상 거의) 모든 인스턴스는 힙 영역에 저장
- Garbage collection 기술은 1960년대 만들어진 LISP 에서 창시

> C++ Game Server 는 임의로 GC 도 만든다고 한다...? 좀비 세션등을 방지하기 위해
> 엄청 어렵지 않고, 만들수는 있는 영역

GC 가 처리해야 할 문제의 핵심 3요소 - LISP 창시자 존 맥카시

- 회수 대상 메모리를 판단하는 것 - 이 판단이 생각보다 복잡하다.
- 메모리 회수 시점 - 언제, 어떻게 회수를 할 것인가
- (구체적인) 메모리 회수 방법

=> 이런 요소들 때문에 세대별 컬렉션이 나온것이다.

### JVM Heap 영역

![600](https://i.imgur.com/5nrE4xg.png)

Young Generation 에서 살아남으면?
-> Old Generation 으로 이동 ( age 값 증가 )
-> 끝날 때 까지 살아남아야 한다면, 선별을 거쳐 Permanent 로 이동

Young Generation 만 처리가 Minor GC
Old Generation 까지 처리하는데 Major GC - 생각보다 찾는 과정이 복잡, 더 시간이 걸림
Permanent 까지 전부 다 뒤지는게 Full GC - 진정한 STW
-> FULL GC 가 발생하면, 장애라고 체감할 만큼 반응성이 떨어진다.

그래서 최대한 Full GC 가 일어나지 않게 코드를 짜는게 중요하다.
## 다형성

> 사전적 정의 : 같은 종의 생물이며, 어떤 형태 및 형질이 다양하게 나타나는 형상

- 객체지향 프로그래밍의 중요한 특징
    - 추상화 or 구체화
    - 추상성이 높은 수준에서 구조를 단순화 할 수 있음
    - Framework 가 구현될 수 있는 원리

전체에 일관되게 반영하기 쉽게 해준다.
실제화 여러개를 관찰하다가, 철학적인 얘기를 통해 묶어 나가는게 추상화

프레임워크 역시도, 추상성을 극대화 시킨것
우리가 `impelements`, `extends` 하면 프레임워크 내부가 알아서 동작시켜준다.

### 부모 - 자식 클래스간 형식 변환

- 업캐스팅 : 자식을 부모로 타입 변환, 실패할 일이 없음
  `MyClass c = new MyClassEx();`

- 다운캐스팅 : 부모를 자식으로 타입 변환, 항상 성공 X, 코드상 말이 되는 경우에만 성공

JVM 입장에선? 우리가 어떻게 클래스 이름을 지을순 알 수 없다.
-> Object 의 파생이므로, 모든걸 처리 가능하다. ( Object 로 간주하면 되니까 )

## 다운 캐스팅과 instanceof 연산자

### 다운캐스팅

- 부모 클래스 형식 참조자가 가르키는 대상 인스턴스를 특정 파생형식으로 캐스팅 하는 것
- 적절치 못한 캐스팅 시 오류 발생
- 모든 클래스는 부모 클래스에 대해 존립 의존적이지만, 부모 클래스에서 다운 캐스팅하는 코드 존재하는 경우
  의존성이 역전되는 좋지 못한 코드가 될 수 있음

사실 좋은 코드는 아니다.
부모가 자식에게 의존성이 생기게 되는 구조이므로
-> 여기에서, 자식이 부모에게 의존을 한다면...? - 미친 순환의존

> 그러게... 이 부분이 꽤나 어렵다.
> 이미 회사의 코드는 다운 캐스팅 형태로 퍼져있다.
> 이걸 고칠순 없지만, 의존성 역전이 되는 곳은 아직 느끼진 못했다.

### instanceof 연산자

`boolean result = obj instanceof instance;`

- 다운 캐스팅이 적절한 것인지 확인할 수 있는 연산자
- RTTI - Run Time Type Information
  코드가 구동되어 돌아가는 시점에 어떤 인스턴스가 어떤 클래스의 파생인지 알 수 있게 해줌
  -> C++ 에선 성능에 유의해야 할 수 있으나, Java 에선 크게 고려하지 않아도 된다고 한다(?)


## 추상클래스

`public abstract class class-name`

- new 연산으론 인스턴스 생성불가
- 파생 클래스를 위해 존재하는 클래스
- 설계적 관점에서 존재
- 추상 메서드 가지는 것이 일반적
    - 추상 클래스만 추상 메서드를 가질 수 있음
    - `abstract void getA...`
    - 파생형식에서 반드시 재정의

## 인터페이스

추상 클래스와 인터페이스는 어떻게 처리할 것인가

```java
abstract class Shape {
	private int data;
	public int getData();
	
	abstract public void render();
}
```

이정도야, 추상 클래스로 선언을 할 의의는 있다.
`int data` + `int getData()` 라는 메소드가 있으니까

### 인터페이스

`[public] interface iface-name`

- 필드 가지지 않는 추상 클래스를 선언한다는 것과 때때론 비슷 - 상수 필드는 가능
- 인터페이스의 파생은 `implements` - `extends` X
- 메소드 원형을 기술하기 위한 것으로, 구체적 정의가 없는 순수한 선언에 가까움
    - 각종 심볼릭 상수
    - 다중상속 가능

> 물론, 이제 default, private 메소드를 제공해주므로 살짝 변질이 되긴 했음

> 꼭 Spring 이 아니더라도, Java 의 이벤트는 Interface 로 이루어져 있다.
> 클라이언트 사이드 기반에선, 특히나 인터페이스 명세를 사용해볼 만하다.

## 열거형

`public enum enum-name {value#0, value#n}`

- 심볼릭 상수를 정의할 수 있는 문법
- 형안정성을 제공하고, 가독성이 좋은 코드를 만들 수 있음

- `java.lang.Enum` 의 파생 클래스

- 주요멤버
    - values(), valueOf(String name)
    - name()
    - ordinal()
    - toString()

## 생각해볼 문제

OOP 에 관한 논쟁은 늘 어디서든 있는 편이다.
사실, OOP 다! 라고 각잡고 얘기를 하지 않아도 OOP 의 애기 일 수 있다.

흔히, 객체지향을 배우고 열정적이면 발생하는 실수
'쓸데 없이 객체화'

이거 정말 생각을 많이 해야 한다.

>사실, 우테코를 다닐때는 무조건 모든걸 다 객체로 만드는게 중요하다고 생각했다.
>하지만, 이것만큼 팀원과 IDEA와 코드를 피곤하게 하는 것도 없을것이다.
>클래스도 결국 부채의 대상, 최대한 적게 만들지만 최대한 효율적이게 쓰여야만 의미 있는게 객체지향

- 잔소리는 충고의 파생형식인가?
- 잔소리, 충고 모두 조언의 파생형식인가?
- 잔소리, 충고, 조언 모두 말하기의 파생형식인가?

ㅋㅋ...

클린 코드의 집착이 오히려 복잡함과 어려움을 가져올 수 있다.
유지보수를 하며, 누더기가 되는건 어쩔수 없는 순리이다.

사실, 새로 짜는게 아닌 이상 이는 피할수 없다. - 최선을 다해 늦추거나, 애초에 처음부터 SOLID 하게 완벽하게 짜거나

=> 그냥 논쟁을 하지말자. 정답은 없다.
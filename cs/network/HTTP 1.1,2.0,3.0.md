0.9 부터 2.0 까지는 기본적으로 TCP 전송 프로토콜 사용

- 0.9 : 원라인 프로토콜 ( `GET /mypage.html` - 이게 끝! )
- 1.0 : 헤더 추가, 응답 상태코드 ( 다른 타입도 전송 가능 )
    - 매번 새로운 연결로 성능 저하
    - 서버 부하 비용 증가

### HTTP 1.1

본격적인 웹 역사 시작

Persistent Connection ( 지정 timeout 동안 커넥션 닫지 않는 방식 )
![](https://i.imgur.com/hNdTbbJ.png)

Pipelining ( 하나의 커넥션에서 응답 기다리지 않고 여려 요청 연속적으로 보내고, 순서 맞게 응답 받는 방식 )

![](https://i.imgur.com/H2RsXVW.png)

HTTP 1.1 은 꽤나 느리다고 평가가 나있다.
-> 파이프라이닝 때문

- 하나의 커넥션에서 한 번에 순차적인 여러 요청 연속적 실행 ( 그 순서에 맞춰 응답해 지연 시간을 줄임 )
  -> 먼저 받은 요청이 끝나지 않으면 먼저 온 요청이 끝날때 까지 대기해야 함
  => HOLB ( Head Of Line Blocking )

> 모던 브라우저들이 이때문에 파이프라이닝 사용을 막음 - 여러 개 커넥션 이용해 데이터 가져옴 ( 병렬 커넥션 )

그리고 중복적인 헤더 구조도 그대로 보낸다.
-> 쓸데없이 커짐

### HTTP 2.0

2015년 등장

기존 1.x 버전의 성능 향상에 초점 맞춘 프로토콜

- 표준 대체가 아닌 확장

현재 네이버,인스타그램,페이스북 등 페이지도 h2 프로토콜을 사용중이다.

>개발자도구 - 네트워크 - 속성에서 우클릭을 하면, 우리 생각보다 훨씬 많은 요소들을 제공해준다

![](https://i.imgur.com/9FjAeDl.png)

- 메시지 전송 방식의 변화가 일어났다.
    - AS-IS : 일반텍스트 형식
    - TO-BE : 바이너리 프레이밍

![](https://i.imgur.com/t1zRNaz.png)

-> 파싱 및 전송 속도 증가

- 스트림이라는 데이터 양방향 흐름 내 프레임들이 들어가서 요청 & 응답 메시지가 되는 것
  -> Request and Response multiplexing
  => Head of Line Blocking 해결

메시지의 순서가 사라짐 + 인터리빙 통해 끼어드는 방식이 가능해짐

![](https://i.imgur.com/SPmM88k.png)

- Stream Prioritization : 리소스간 우선순위 지정 가능
- Server Push : 클라이언트가 요청하지 않은 리소스 알아서 Push ( html 요청시, CSS도 같이 보내줌 )
- Header Compression : 헤더 크기 줄여 페이지 로드 시간 감소

Static Table 을 만들고 중복된거는 인덱스만 뽑고,
아니면 허프만 인코딩 통해 인코딩을 해서 헤더 자체를 압축해 보냄

### QUIC

전송 계층 프로토콜
구글에서 만들고, 2013년 공개 ( 구글 관련 제품 대부분의 기본 프로토콜 )

UDP 기반 WHY?

- TCP는 신뢰성을 확보하나 꽉 차있어서 지연을 줄이기 힘든 구조

![](https://i.imgur.com/tiXjnwm.png)

![](https://i.imgur.com/ahnxWm8.png)

데이터 전송에 기반한 설계
별도 기능 X
-> 원하는 기능 구현 O
-> TCP 지연을 줄이며 TCP만큼 신뢰성 확보 가능

![](https://i.imgur.com/MKIG7xZ.png)

- 전송 속도 향상!!!
  첫 연결 전송에서 필요한 정보와 함께 데이터 전송
  -> 연결 성공 시 설정 캐싱해 다음 연결 때 바로 성립 가능
  ( 핸드쉐이크 자체가 없음 )

Connection UUID 통한 고유 식별자로 서버와 연결
-> 커넥션 재수립 필요 X

- 보안요소 역시 적용
  TLS 기본 적용
  IP Spoofing / Replay Attack 방지 - 소스 어드레스 토큰을 통해 한다(?)

- 독립 스트림을 활용해 향상된 멀티플렉싱 가능

기존 TCP Head Of Line Blocking은?
중간 데이터가 손실나면 나머지가 다 대기하고 있어야 했다. ( 상관없는 데이터라도 )

-> 독립된 스트림을 통해 상관없이 데이터 전송

=> 구글 로딩 시간 평균 3% 개선, 유투브 시청 중 버퍼링 평균 30% 개선!

### HTTP 3

2018년에 나왔지만, 다소 아직은 지켜봐야 할 것
( 왜냐면 아직 구글 말고 접목을 시킨 곳이 없다고 느껴지기 때문 )

물론 2022년 부터 CloudFront 도 HTTP 3을 지원했다고 한다.

## 근본적인 문제

왜 1.1 보다 2가 좋은걸 알고, 2보다 3이 더 좋은걸 아는데 모두가 무조건 그걸 적용하지 않는걸까?
호환의 문제가 발생할 수도 있고, UDP 트래픽 정책이 꺼려지는 사람이 있을수도 있고 등등등

점진적으로 시간이 지나며 해결이 되길 빌어야 하는 요소일 것이다.

> Spring 도 2024년 11월에 HTTP 3을 지원한다고 설명했다.
> ( Reactor 에서 HTTP 3 을 활성화가 가능하다고 공개 )

# SSL, TLS

SSL 과 TLS 를 위해 전체적인 내용을 기반으로 시작해보자.

### TCP

- 연결 지향형 : 연결 되어있는지 확인후 연결, 3-way handshake ( SYN -> SYN/ACK -> ACK ) 연결 수립

처음 리슨포트에서 연결을 수신 -> 그 후, 전용 소켓 만들어서 통신
( 전용 소켓은 클라이언트의 IP,포트 + 서버의 IP, 포트 를 활용해 식별가능 )

하지만, 단순히 HTTP + TCP 통신으로는 패킷을 까면 모든 내용을 확인 가능하다.
### 대칭키, 비대칭키

- 대칭 키 : 하나의 키로 암호화 / 복호화 - 빠르고, 실시간 트래픽

대칭 키로만 통신하면, 키를 주고받는 과정에서 도난을 당할 수 있다.
(결국, 키를 주고 받는 과정은 평문)
-> 비대칭키의 필요성

- 비대칭 키 : 두 개의 키로 암호화 / 복호화 - 키 교환, 서명 인증에 강점이 있으나, 느림

A 로 암호화를 하면? -> B 로만 복호화 가능
B 로 암호화를 하면? -> A 로만 복호화 가능

서버는 개인키를 가지고, 클라이언트는 공개 키를 ( 공개 되어 있음 ) 기반으로 대칭키를 암호화를 한다.
-> 그 후, 대칭 키로 암/복호화 해서 주고 받는다.

> 대칭키를 서버 공개키로 암호화해 전달은 구 TLS 1.2 의 RSA 키 교환
> 현행 TLS 1.3 은 ECDHE ( 타원 곡선 ) 로 '공유 비밀' 를 합의하고, 세션키를 파생한다고 함

-> 키를 전송하는 과정을 탈취하면? - 개인키가 없어서 복호화 불가능
-> 데이터를 주고받는 과정을 탈취 하면? - 대칭키가 없어서 복호화 불가능

#### 중간자 공격

하지만, 이와같은 공격이 발생할 수 있다.
해커가 자신의 개인키로 암호화 한 공개키를 `서버의 공개키` 인 것처럼 위장을 한다!
-> 해커의 서버를 올바른 서버로 판단하고 요청을 보내면?
-> 해커는 자신의 개인키로 복호화해 데이터를 탈취할 수 있다.

=> 그렇기에 이런 공개키를 신뢰할 수 있는 방법이 필요해졌다. ( 인증서 )

### 인증서

PKI : Public Key Infrastructure, CA, 인증서, 서버, 클라이언트 등이 얽혀 신뢰 관계 구축하는 전체 시스템

신뢰할 수 있는 제 3자 기관이 '공개키가 이 도메인 것이 맞다' 를 보증해줌

- 작동 원리
1. 서버 : 서버 정보(도메인 등) 과 공개키를 CA 에 제출해 인증서 발급 신청
2. CA : 서버의 정보를 검증하고, 다음 정보 포함하는 인증서 생성
    - 서버 공개키, 도메인 주소, 소유자 정보
    - 인증서 유효 기간, 발급자 정보
3. CA 의 서명 : CA 는 인증서 내용 해싱, 해시값을 자신의 개인키로 암호화해 인증서 첨부
4. 클라이언트의 검증
    - 클라이언트는 신뢰할 수 있는 CA 목록 및 공개키를 미리 내장 - Trust Store
    - 서버로부터 인증서 받으면, 인증서에 서명한 CA 확인
    - 내장된 CA 공개키 사용해 인증서 디지털 서명을 복호화
    - 복호화된 해시값과, 클라이언트가 직접 인증서 해시한 값이 일치하는지 비교

### SSL ? TLS

현재는, SSL 의 후속인 TLS 를 통해 보안이 이루어진다.

TLS 는 기존 버전의 취약점을 해결하기 위해 SSL 3.0 업그레이드 버전으로 공개되었다.

이와 같은 방식으로 인증이 진행된다.
1. Client Hello, 랜덤 데이터 + 지원할 수 있는 암호화 방식 서버에 전송
2. Server Hello, 랜덤 데이터 + 지원할 수 있는 암호화 방식 전송 + 인증서 클라이언트에 전송
3. 클라이언트는 인증서가 제대로 된 문서인지 검증하기 위해 CA 가 발급한 목록중 인증서 있는지 확인
   CA 가 공유하는 공개키 가지고 서명이 유효한지 검증 - 복호화가 성공하면, CA 의 비밀키로 암호화 된 걸 보장
4. 클라이언트가 실제 통신에 사용할 대칭키를 임시 생성 ( 주고 받은 임시 데이터로 생성 )
   -> 앞서 가지고 있는 공개키로 복호화 해서 전달
5. 키를 받은 서버는 비밀키로 복호화해 임시 키를 전달
6. 임시 키는 일련 과정을 거쳐 세션 키로 바뀌고 본격적인 통신

데이터 전송 끝나면, 세션 종료해서 통신을 마침 ( + 세션 키도 함께 삭제 )

#### ECHDE, PFS

- PFS : Perfect Forward Secrecy, 완전 순방향 비밀성

즉, 과거에 암호화된 통신 내용은 미래에 서버의 비밀키가 유출되어도 해독할 수 없게 하는 것

이게 안된다면?
해커가, 1년 동안 암호화 된 데이터를 탈취하고 있었을 때?
-> 장기 개인키를 훔치면 1년 동안의 데이터를 복호화해서 볼 수 있게 된다

- ECHDE : Elliptic Curve Diffie-Hellman Ephemeral

그냥 보기만 해도 어렵다..
간락하게

- Diffie-Hellman : 안전하지 않은 통신망에서 두 사람이 안전하게 비밀 키를 공유하게 해줌

아래의 비유 by Gemini

```
1. 공통 색 결정 : A 와 B 가 노란색 물감을 사용하기로 합의
2. 각자 비밀 색 추가 : 
   A 는 자신이 아는 빨간색을 사용해 주황색
   B 는 자신이 아는 파란색 사용해 초록색
3. 교환 : 서로에게 자신의 색을 보냄 ( A -> B 에게 주황색, B -> A 에게 초록색 )
4. 최종 비밀 만들기 :
   A 는 B에게 받은 초록색과 빨간색을 사용해 갈색
   B 는 A에게 받은 주황색과 파란색을 사용해 갈색
   
결국, 두 비밀색을 모르면 최종 색 갈색을 유추할 수 없다.
```

- Elliptic Curve : 기존 디피-헬만은 매우 큰 소수로 복잡한 수학 계산이 필요했음, 훨씬 작은 키로 동일 & 더 높은 수준 보안 제공

이를 통해, 스마트폰 및 저사양 컴퓨터도 빠르고 안전한 통신이 가능

- Ephemeral : 매 통신마다 새로운, 일회용 키 사용

임시 키를 통해 세션 키 만들면, 임시 키는 즉시 폐기
-> 위, PFS 를 가능하게 해주는 것
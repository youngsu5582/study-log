Long Polling 의 문제점 때문에 나온 요소

## Long Polling

전통적인 폴링 방식의 단점을 보완한 기술

1. 클라이언트 요청 : 클라이언트가 일반적인 HTTP 요청을 서버로 보냄
2. 서버 대기 : 서버는 요청을 받자마자 응답이 아닌, 클라이언트에게 보낼 새로운 데이터가 생길 때 까지 응답 보류 & 연결 유지
3. 데이터 발생 및 응답 : 서버에 새로운 데이터 발생하면, 클라이언트에게 데이터를 담아 응답 보냄 & 연결 종료
4. 클라이언트 즉시 재요청 : 클라이언트는 응답 받자마자, 다음 데이터를 기다리기 위해 새로운 요청을 다시 서버로 보냄
5. 타임아웃 : 정해진 시간 동안 새로운 데이터가 발생하지 않으면, 서버는 빈 응답을 보냄 & 연결 종료
   클라이언트는 응답 받고 즉시 재요청 보냄

### 특징

- 높은 호환성 : 오래된 브라우저라도 표준 HTTP 사용하므로 호환성 문제 거의 X
- 서버 부하 : 요청마다 새로운 연결을 맺고 닫으므로 SSE 및 WebSocket 에 비해 서버 부하를 더 많이 줌
- 구현 복잡성 : 서버 측에세 연결은 대기시키되, 타임아웃 관리도 해야하므로 복잡함
- 실시간 성의 한계 : 데이터 발생 후 응답 보내고, 클라이언트가 다시 보내는 사이 지연 존재

=> 즉, 레거시 환경에서 제공할 때 사용 가능하다.

## Server Send Event

서버가 클라이언트에게 단방향으로, 지속적 연결을 통해 실시간 데이터를 전송하는 HTML 5 표준 기술

1. 클라이언트 요청 : 클라이언트는 JavaScript 의 EventSource 객체 생성해 서버 특정 엔드포인트로 HTTP 요청 보냄
2. 서버 응답 & 연결 유지 : 서버는 요청에 대해 `Content-Type: text/event-stream` 헤더와 응답하고, 연결 끊지 않고 계속 유지
3. 데이터 전송 : 서버는 새로운 데이터, 이벤트 발생 때마다 열린 연결을 통해 클라이언트에게 정해진 형식의 텍스트 데이터 보냄
4. 클라이언트 이벤트 수신 : 클라이언트는 EventSource 객체 `onMessage` or `addEventListener` 통해 데이터를 실시간으로 수신 및 처리

### 특징

- 단방향 통신 ( Server -> Client ) : 데이터는 항상 서버 -> 클라이언트, 클라이언트가 서버로 데이터 보내려면 별도 HTTP 요청
- 자동 재연결 : 네트워크 문제 등 연결 끊기면, 브라우저가 자동 재연결 시도.
  재연결 시 마지막으로 수신한 이벤트 id 를 헤더에 담아 보내면, 서버는 놓친 데이터부터 다시 보냄

```HTTP
GET /stream-endpoint HTTP/1.1
Host: example.com
Accept: text/event-stream
Last-Event-ID: 1003
```

브라우저가 연결이 끊긴걸 감지하면 ( EventSource 의 onerror 라던가, 서버가 retry 필드로 시간 조절도 가능 )
자신이 마지막으로 기억하는 ID 를 담아서 보낸다.

서버는 재연결 요청 받고, 요청 헤더에 Last-Event-ID 가 포함되어 있는지 확인
헤더 값 읽고, 그에 맞게 유실된 데이터를 보내주는 로직을 구현해야함

- 간단한 구현 : 표준 HTTP 프로토콜이므로, WebSocket 에 비해선 간단 ( 특별한 라이브러리 없어도 구현 )
- 이벤트 타입 : event 필드를 사용해 메시지 종류 구분해, 클라이언트가 종류별 다른 로직 처리하기 용이

LLM 서비스가 SSE 를 사용하는 이유는 명확하다.

`전체 답변이 완성되지 않더라도 사용자가 기다리게 하지 않고, 생성되는 단어들을 즉시 사용자 화면에 보여주기 위함`

사용자가 질문을 보내면?
-> LLM 이 첫 토큰 ( EX: 안녕하세요 ) 을 생성하자마자 SSE 연결을 통해 클라이언트에게 전송

실시간으로 작업 중인게 느껴진다.

- vs Long Polling : 롱폴링은 연결이 매번 이루어지므로, 매 토큰마다 요청-응답-재요청을 반복해야 함
  -> 엄청난 수 HTTP 요청 유발, 헤더 오버헤드 및 지연 시간으로 인해 매우 비효율

- vs WebSocket : 양방향 통신을 위한 기술, LLM 은 서버가 클라이언트에게 일방적 요청을 보내는 흐름
  -> 불필요

---

### 기타

- 롱폴링은 사실상 이벤트 루프 기반 요청을 처리하는게 필연적이다.
  -> 동기 방식이면 응답 대기하는 동안 스레드가 묶여 있음

- 중간 프록시 서버 & 방화벽이 멋대로 아무 데이터가 오가지 않는 유후 연결을 끊는 경우가 존재한다.
  -> 주석 및 메시지 보내서 연결이 살아있음을 유지해야함 ( Keep-Alive )

- 여러 줄로 보내야 하면, data 필드를 여러번 사용

```
data: {
data:   "user": "Gemini",
data:   "text": "이것은 여러 줄로 된 JSON 데이터입니다."
data: }
```

줄바꿈 문자를 통해서 합쳐서 처리

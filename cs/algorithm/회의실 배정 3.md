# 회의실 배정 3

- 문제 링크 : https://www.acmicpc.net/problem/19622

이거 엄청 쉬운 DP 인데
점화식에서 좀 헤맸음...

-3 + n
-2 + n
으로 접근함

근데, 그게 아니라 '이전 꺼를 그냥 사용할지', ' 그전 요소 + 현재 요소를 사용할지' 를 점화식으로 잡아야 한다.

```java
    // 23:14 -

    // N 개의 회의, 하나의 회의실

    // 회의는 시작 시간, 끝나는 시간, 회의 인원
    // 한 회의실에서 동시 두 개 이상 회의 진행 불가능

    // 회의 시작 시간은 끝나는 시간보다 항상 작음
    // N 개 회의 효율적 배정 시, 진행할 수 있는 최대 인원

    // 1 <= N <= 100,000

    // K 회의는 무조건, K-1 & K+1 가는 시간이 겹침 ( 다른 회의와는 시간 겹치지 않음 ) ⭐️???
    // 모든 회의 시작 시간, 끝나는 시간은 다름
    // 회의 인원 <= 1000

    // 즉, 적절히 회의 선택했을때 가장 큰 걸 먼저 선택...?
    // 그리고, 그 인접한 회의는 선택할 수 없게 된다.
    // 그럼에도 가장 큰 회의를 선택하는게 맞는가?

    // (K-1) + (K+1) >

    // 100 150 130 50 90

    // 150을 선택하면? -> 240

    // 100, 130 을 선택하면? -> 320

    // 80 60 70 100 40 50

    // 80 .. .. 100
    // .. 60 .. 100

    // 80 60 150 180 40 50
    // 80 60 150 180 190 230

    // 단순 DP...?

    // 100 150 130 120 90

    // 100 150 130 270 220

    // 41 50 30 20 40 60 70 5 50 51

    // 41 50 30 71 90 131 160 136 210 211

    // 211?
    // 그 순간 최고의 값이 최적의 해

    // 150 + 120 = 270
    // 결국, 이걸 선택할 지 다음걸 선택할지 인가...?

    public static void main(final String[] args) throws IOException {

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());

        int[][] data = new int[n][3];

        for (int i = 0; i < n; i++) {
            int[] temp = Arrays.stream(br.readLine().split(" ")).mapToInt(Integer::parseInt)
                .toArray();
            // 필요한 값만 추출
            // 이 아니라, 정렬도 적절히 처리되어야 함
            data[i][0] = temp[0];
            data[i][1] = temp[1];
            data[i][2] = temp[2];
        }

        data = Arrays.stream(data).sorted(Comparator.comparingInt(ary -> ary[0]))
            .toArray(int[][]::new);

        // 2부터 시작할 거니까 0 처리
        if(n == 1){
            System.out.println(data[0][2]);
            return;
        }

        int[] ary = new int[n];

        // DP 세팅
        for (int i = 0; i < n; i++) {
            ary[i] = data[i][2];
        }
        // 1을 선택하지 않더라도 최대가 되기 위해서 ary[0]
        ary[1] = Math.max(ary[0], ary[1]);

        // 일종의 DP
        for (int i = 2; i < n; i++) {
            ary[i] = Math.max(data[i][2] + ary[i - 2], ary[i - 1]);
        }

        System.out.println(Arrays.stream(ary).max().getAsInt());
    }
}
```
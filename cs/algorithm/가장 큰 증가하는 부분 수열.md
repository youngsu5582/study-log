# 가장 큰 증가하는 부분 수열

- 문제 링크 : https://www.acmicpc.net/problem/11055

```java
// 12:01 - 12:52
public static void main(final String[] args) throws IOException {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int n = Integer.parseInt(br.readLine());
    StringTokenizer st = new StringTokenizer(br.readLine());

    int[] ary = new int[n];
    int index = 0;
    while (st.hasMoreTokens()) {
        ary[index++] = Integer.parseInt(st.nextToken());
    }

    // 수열이 증가하는 부분에서 합이 가장 큰 것

    // 결국, 그 순간 순간 가장 큰걸 선택 해야만 한다...?

    // 1 100 2 50 60 3 5 6 7 8

    // 1 2 50 60 = 113

    // N 은 1000개

    // 계속해서, bfs 처럼 선택??
    // 기하급수적으로 늘어남
    // 1 -> 선택, 선택 안함
    // 2 -> 선택, 선택 안함...
    // 2^1000 ?

    // 적절히, 가장 큰 숫자부터 시도해본다...?

    // 그냥하면 N ^ 2
    // 적절히 뒤에서부터 앞으로

    // 뒤에서부터, 적절히 자기보다 작은거를 계속 항해
    // 만약, 자기보다 큰 값을 만났다면?
    // -> 그게 체크 포인트
    // 다음에는 그거부터 시작

    // 똑똑한 N^2 -> n log n

    //
//        int max = 0;
//        for (int i = n - 1; i >= 0; i--) {
//            int checkPoint = -1;
//            int value = ary[i];
//            int sum = value;
//            for (int j = i; j >= 0; j--) {
//                System.out.println(i + "\t" + checkPoint + "\t" + value + "\t" + sum);
//                if (value > ary[j]) {
//                    sum += ary[j];
//                    // 계속 교체
//                    value = ary[j];
//                }
//                // 자기랑 같은건 어차피 필요없음
//                if (checkPoint == -1 && value < ary[j]) {
//                    checkPoint = j;
//                }
//            }
//            // checkPoint 를 찾았으므로 바로 교체
//            // checkPoint 가 -1 여도? 상관없음 그러면 1 2 3 4 5 처럼 계속 더 작았다는 의미
//            max = Math.max(max, sum);
//
//            // i-- 이므로, -1 될 걸 생각해서 + 1
//            i = checkPoint + 1;
//        }
//        System.out.println(max);

    int[] dp = Arrays.copyOf(ary, ary.length);

    // i 를 확인
    for (int i = 0; i < ary.length; i++) {
//            System.out.println(i);
        for (int j = i + 1; j < ary.length; j++) {
            // i 보다 뒤 + i 보다 클 때
            if (j > i && ary[j] > ary[i]) {
                // 기존 최대값 + 자기 or 현재 최대 값
                dp[j] = Math.max(ary[j] + dp[i], dp[j]);
            }
        }
//            System.out.println(Arrays.toString(dp));
    }
    System.out.println(Arrays.stream(dp).max().getAsInt());

}

// 8
// 7 8 9 2 6 7 8 10
// -> 33이 나온다...?

// 7 8 9 10
// -> 34
// 방법이 틀림. 결국, 언제든 앞에가서 최대값을 찾을 수 잇어야 하는데
// 내 방법은 그리디로, 순간순간 최고인걸 찾음

// DP 로 풀어야만 한다.

// 최적 부분 구조가 되는가? : 정답이, 그 보다 작은 부분의 최적 해결책으로 구성
// 중복되는 부분 문제 : 똑같은 작은 문제들이 부분적으로 반복되는지

// 적절한 N ^ 2 으로 DP 로 풀어야 한다
// 처음에 각 원소를 가지는 DP 값 선언
// 그 후, 각 요소 + 배열 순회해서 DP 배열을 갱신
```
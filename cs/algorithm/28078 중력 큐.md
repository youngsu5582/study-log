# 중력 큐

- 문제 링크 : https://www.acmicpc.net/problem/28078

쉽지 않다....

구현 실력이나, 접근은 좋았는데
removeFirst, removeLast
addFirst, addLast 에서 완전히 꼬여버린듯

2,3 일뒤 다시 풀어보기

```java
public static void main(final String[] args) throws IOException {

    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

    int n = Integer.parseInt(br.readLine());

    // push b / w : 큐 뒤에 공 / 가림막 하나 삽입
    // pop : 가장 앞에 있는 공 or 가림막 꺼냄 ( 빈 상태면 아무일 X )
    // rotate l : 반시계 방향 90도 회전
    // rotate r : 시계 방향 90도 회전

    // count b : 현재 들어있는 공 개수 출력
    // count w : 현재 들어있는 가림막 개수 출력

    // 처음에는 왼쪽이 큐의 뒤
    // 오른쪽이 큐의 앞
    // 뒤 ------- 앞

    // 뒤 ------ 앞
    //
    // 시계방향 : 뒤
    //          |
    //          |
    //          앞

    // 0 : 뒤 - 앞

    // 1 : 뒤
    //     -
    //     앞

    // 2 : 앞 - 뒤

    // 3 : 앞
    //     -
    //     뒤

    // b b w b
    // 가장 앞에를 제거
    // b b w

    // b
    // b
    // w

    // push b
    // rotate r
    // count b -> 0
    // rotate r  앞 - 뒤
    // b
    // b w

    // rotate r 앞
    //          뒤
    // b
    // w

    // push b b
    // b
    // w
    // -> 바로 떨어짐

    // count b -> 1
    // 뒤 앞

    // push b
    // b w b

    // count b -> 2
    // 실화...?

    // 현재, 큐 상태가 중요함
    // 가림막이 어디있는지도 중요함
    // -> 즉, rotate 될 때 가림막 아래 있는 거는 다 제거될 예정

    // 뒤 - 앞
    // pushFirst
    // 앞 - 뒤
    // pushLast

    // 1번 ( 뒤
    //       앞 )

    // 인 경우 push 는?

    // pushFirst
    // 3번 ( 앞
    //      뒤 )

    // 큐 안에 가림막은 중력 영향 X, 공은 중력 영향 -  가림막 보다 아래에 있으면 공 모두 떨어짐
    // 큐가 세로 방향일 때는 공을 새로 넣더라도, 가림막 없으면 곧바로 큐에서 꺼내짐!!

    // 가림막 위치를 저장? ( 위치로 저장하면, rotate 할때 깨질수 있음 )
    // 일단 push 부터 시작

    Deque<Integer> dq = new ArrayDeque<>();

    // 뒤 - 앞 으로 시작
    int direction = 0;

    // 그냥 count 돌리니 시초 뜬다.. 25만 ^ 25...?

    for (int i = 0; i < n; i++) {
        String line = br.readLine();
        int[] commands = parse(line);
        int command = commands[0];
        int value = commands[1];

//            System.out.println(line + " " + "direction: " + direction + "\t" + dq);

        // PUSH
        if (command == 0) {
            // 뒤 --- 앞
            if (direction == 0) {
                // 0 이 공, 1 이 가림막
                plusCount(value);
                dq.addFirst(value);

            }
            // 어차피, rotate 일때, 맨 밑에는 처리가 된다고 가정(즉, 마지막이 무조건 가림막인지만 확인 or empty)
            // 1번 ( 뒤
            //       앞 )
            else if (direction == 1 && dq.getLast() == 1) {
                plusCount(value);
                dq.addFirst(value);
            } else if (direction == 1 && value == 1) {
                plusCount(value);
                dq.addFirst(value);
            }
            // 앞 ---- 뒤
            else if (direction == 2) {
                plusCount(value);
                // 뒤가 오른쪽이거나, 아래
                dq.addLast(value);
            }
            // 앞
            // 뒤
            // 일떄는 사실상 절대 못넣음
            // 인줄 알았지만, 벽은 그냥 넣어도 됨 ㅇ.ㅇ
            //
            else if (direction == 3 && value == 1) {
                dq.addLast(value);
            }

            // 세로라면? 가림막 체크

            // 1번 ( 뒤
            //       앞 )

            // 인 경우 push 는?

            // pushFirst
            // 3번 ( 앞
            //      뒤 )
            // 인 경우 push 는?

            // pushFirst
            // 3번 ( 앞
            //      뒤 )

        }
        // POP
        // 하... 여기도 생각해야 함
        if (command == 1) {
            // 뒤가 위 or 왼쪽
            if (direction == 0 || direction == 1) {
                int element = dq.removeLast();
                minusCount(element);
            } else {
                int element = dq.removeFirst();
                minusCount(element);
            }

            if (direction == 1) {
                while (!dq.isEmpty()) {
                    int element = dq.removeLast();
                    if (element == 1) {
                        dq.addLast(element);
                        break;
                    }
                    minusCount(element);
                }
            }

            if (direction == 3) {
                // first -> last
                // 3번 ( 앞
                //      뒤 )
                while (!dq.isEmpty()) {
                    int element = dq.removeLast();
                    if (element == 1) {
                        dq.addLast(element);
                        break;
                    }
                    minusCount(element);
                }
            }
        }

        // ROTATE
        if (command == 2) {
            // l 이면 -- ( 반시계 )
            // r 이면 ++ ( 시계 )
            if (value == 1) {
                direction++;
            } else {
                direction--;
            }
            // 4 초과하면, 나머지로 초기화
            // 음수, 될 수 있으므로 + 4
            direction = (direction + 4) % 4;
            // 1번 ( 뒤
            //       앞 )
            // 가림막을 찾을때까지 다 제거
            if (direction == 1) {
                // last -> first
                // 비거나, 가림막을 찾거나
                while (!dq.isEmpty()) {
                    int element = dq.removeLast();
                    if (element == 1) {
                        dq.addLast(element);
                        break;
                    }
                    minusCount(element);
                }
            }

            if (direction == 3) {
                // first -> last
                // 3번 ( 앞
                //      뒤 )
                while (!dq.isEmpty()) {
                    int element = dq.removeLast();
                    if (element == 1) {
                        dq.addLast(element);
                        break;
                    }
                    minusCount(element);
                }
            }
        }

        // COUNT
        // b 이면 0 출력
        // w 이면 1 출력
        if (command == 3) {
            if (value == 0) {
                System.out.println(ballCount);
            } else {
                System.out.println(wallCount);
            }
        }
    }

}

//push b
//push b
//push b

// 0 : push
// 1 : pop
// 2 : rotate
// 3 : count

// b,l : 0
// w,r : 1
private static int[] parse(String line) {
    StringTokenizer st = new StringTokenizer(line);

    // POP
    if (st.countTokens() == 1) {
        // pop 만 고정후 뒤는 아무렇게 반환
        return new int[]{1, -1};
    }
    int commandValue = decide(st.nextToken());
    int value = decideSecond(st.nextToken());
    return new int[]{commandValue, value};
}

private static int decide(String line) {
    if (line.equals("push")) {
        return 0;
    } else if (line.equals("pop")) {
        return 1;
    } else if (line.equals("rotate")) {
        return 2;
    } else {
        return 3;
    }
}

private static int decideSecond(String line) {
    if (line.equals("b") || line.equals("l")) {
        return 0;
    }
    if (line.equals("w") || line.equals("r")) {
        return 1;
    }
    return -1;
}

private static void plusCount(int value) {
    if (value == 0) {
        ballCount++;
    } else {
        wallCount++;
    }
}

private static void minusCount(int value) {
    if (value == 0) {
        ballCount--;
    } else {
        wallCount--;
    }
}
```
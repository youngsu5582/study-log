# 미로 탈출

- Link : https://www.acmicpc.net/problem/14923

```java
import java.io.*;
import java.util.*;

public class CodingApplication {

    // 11: 48 ~ 12:55
    public static void main(final String[] args) throws IOException {
        // N * M 미로

        // Hx, Hy 떨어짐

        // 탈출 위치 Ex, Ey
        // 설치 벽

        // 벽을 길로 한번만 교체 가능 ( 시간 X )

        // 미로에서 탈출할 수 있는지 + 가장 빠른 경로 거리

        // 0이 빈 칸, 1이 벽
        // 1부터 시작

        // 2 <= N, M <= 1000
        // 1 <= Hx,Hy,Ex,Ey <= 1000

        // 특정 벽을 부수고 최단거리로 이동
        // 이때, 벽을 부순걸 기반으로 이동을 고려

        // 1. 그냥 시작
        // 2. 벽을 부순 경우로 이동

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int[] nm = Arrays.stream(br.readLine().split(" ")).mapToInt(Integer::parseInt).toArray();
        int[] hXY = Arrays.stream(br.readLine().split(" ")).mapToInt(Integer::parseInt).toArray();
        int[] eXY = Arrays.stream(br.readLine().split(" ")).mapToInt(Integer::parseInt).toArray();

        n = nm[0];
        m = nm[1];

        hx = hXY[0];
        hy = hXY[1];

        ex = eXY[0];
        ey = eXY[1];

        int[][] ary = new int[n][m];
        for (int i = 0; i < n; i++) {
            StringTokenizer st = new StringTokenizer(br.readLine());
            int[] temp = new int[m];
            int index = 0;
            while (st.hasMoreTokens()) {
                temp[index++] = Integer.parseInt(st.nextToken());
            }
            ary[i] = temp;
        }
        //        // 벽이 하나도 없는 경우를 대비해 초기 상태에서 한번 실행
        //        // 어떻게 최적화...?
        //        for (int i = 0; i < n; i++) {
        //            for (int j = 0; j < m; j++) {
        //                // 벽 교체후 다시 원복
        //                if (ary[i][j] == 1) {
        //                    ary[i][j] = 0;
        //                    answer = Math.min(bfs(ary), answer);
        //                    ary[i][j] = 1;
        //                }
        //            }
        //        }
        answer = newBfs(ary);
        // 탐색할 수 없는 경우
        if (answer == Integer.MAX_VALUE) {
            System.out.println(-1);
        } else {
            System.out.println(answer);
        }
    }

    static int n;
    static int m;

    static int hx;
    static int hy;

    static int ex;
    static int ey;

    static int answer = Integer.MAX_VALUE;

    // 처음에서 다음 위치로 이동시 1 추가

    private static int bfs(int[][] wall) {
        boolean[][] visited = new boolean[n][m];

        Deque<int[]> deque = new ArrayDeque<>();
        // 시작 넣기
        // 처음에 -1, -1 ( 그래야 zero index )
        deque.push(new int[]{hx - 1, hy - 1});
        int depth = 0;
        while (!deque.isEmpty()) {

            // 불필요한 탐색하지 않기 위함
            if (depth >= answer) {
                return Integer.MAX_VALUE;
            }

            int size = deque.size();
            for (int i = 0; i < size; i++) {
                int[] element = deque.pop();
                int x = element[0];
                int y = element[1];
                // 마지막에 +1, +1 로 확인
                if (x + 1 == ex && y + 1 == ey) {
                    return depth;
                }

                // 4방향 이동
                for (int[] direction : DIRECTIONS) {
                    int nextX = x + direction[0];
                    int nextY = y + direction[1];

                    // 이동 가능
                    if (0 <= nextX && nextX < n && 0 <= nextY && nextY < m) {
                        // 벽이 아니고, 방문한 적 없는 경우
                        if (wall[nextX][nextY] == 0 && !visited[nextX][nextY]) {
                            visited[nextX][nextY] = true;
                            deque.add(new int[]{nextX, nextY});
                        }
                    }
                }
            }
            depth++;
        }
        return Integer.MAX_VALUE;
    }

    // 오른쪽, 아래, 왼쪽, 위
    private static int[][] DIRECTIONS = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};

    // => 오케이 뭔 느낌인지 이해함
    // 지금은 (N^M)^2 -> 불가능

    // 근데, 그 대신에 특정 영역에 벽을 부수고 도달한 것과 벽을 부수지 않고 도달한 것
    // 을 알 수 있다.

    // 자신이 이동하면서 계속 경우를 늘려야함
    // 벽이네? -> 벽 기회를 소모하고 이동
    // 빈공간이네? -> 그냥 이동 ...

    // 결국, 끝에 제일 빨리 도달하는게 최고...?
    // 이건 조금 고민 - 상태에 따라 달라질 수 있기 때문

    // 근데 어떻게 visited 를 판별?
    // 2개로 나눠서? - 벽을 부수고 온거, 벽을 부수지 않고 온거??

    private static int newBfs(int[][] wall) {
        // 0: 벽을 부수지 않고 도달
        // 1: 벽을 부수고 도달
        boolean[][][] visited = new boolean[n][m][2];

        Deque<int[]> deque = new ArrayDeque<>();
        // 시작 넣기
        // 처음에 -1, -1 ( 그래야 zero index ) + 1 ( 벽을 부술 기회 ) + 현재 depth
        deque.push(new int[]{hx - 1, hy - 1, 1, 0});
        while (!deque.isEmpty()) {

            int size = deque.size();
            for (int i = 0; i < size; i++) {
                int[] element = deque.pop();
                int x = element[0];
                int y = element[1];
                int chance = element[2];
                int depth = element[3];

                // 마지막에 +1, +1 로 확인
                if (x + 1 == ex && y + 1 == ey) {
                    return depth;
                }

                // 4방향 이동
                for (int[] direction : DIRECTIONS) {
                    int nextX = x + direction[0];
                    int nextY = y + direction[1];

                    // 이동 가능
                    if (0 <= nextX && nextX < n && 0 <= nextY && nextY < m) {
                        // 벽인 경우, 부술 수 있는 경우
                        // 벽을 부순 행위를 기록 or 다른 곳에서 벽을 부수고 들어온 경우를 기록??

                        // 어렵다...
                        // 지금은 앞의 경우를 생각했는데, 이러면 벽을 부수고 온 상태인지 안부수고 온 상태인지 파악이 어려움
                        // visited 가 3개...? ( 0: 벽을 부수지도 않고, 처음 방문 <-> 1: 이번에 벽을 부수고 도달, 2: 다른곳에서 벽을 부수고, 여긴 처음 방문...? )
                        // int 로...? - 지금보다 더 작으면 와이 낫?
                        if (wall[nextX][nextY] == 1 && chance == 1 && !visited[nextX][nextY][1]) {
                            visited[nextX][nextY][1] = true;
                            deque.add(new int[]{nextX, nextY, 0, depth + 1});
                        }
                        // 벽이 아니고, 이동한 적 없는 경우 ( 이미 벽 부술 기회 소진 )
                        if (wall[nextX][nextY] == 0 && chance == 0 && !visited[nextX][nextY][1]) {
                            visited[nextX][nextY][1] = true;
                            deque.add(new int[]{nextX, nextY, chance, depth + 1});
                        }

                        // 벽이 아니고, 이동한 적 없는 경우 ( 벽 부술 기회 소진 X )
                        if (wall[nextX][nextY] == 0 && chance == 1 && !visited[nextX][nextY][0]) {
                            visited[nextX][nextY][0] = true;
                            deque.add(new int[]{nextX, nextY, chance, depth + 1});
                        }
                    }
                }
            }
        }
        return Integer.MAX_VALUE;
    }
}
// 어차피, 맨 앞이 제일 선구자...?

// 0 1 1 1 1 1
// 0 1 0 0 0 1
// 0 0 1 0 0 0
// 0 0 0 0 0 0
```

쩝.. 힌트를 받고 풀긴 함
사실, 변이 bfs 인걸 눈치채야 하는게 포인트 였는듯

- visited 가 무조건 2차원일 것이라는 생각하지 말기
- 시간 복잡도 고려하기 ( 솔직히 N^2 ^ 2 이여서 안될거 알고는 있었음 )

https://boj.kr/2206 이 문제로 다시 트라이해보기
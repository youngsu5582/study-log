# 어두운 굴다리

- 문제 링크 : https://www.acmicpc.net/problem/17266

```java
import java.io.*;
import java.util.*;
import java.util.stream.*;

public class CodingApplication {

    // 22:44 - 23:10
    // 실버 4치곤 생각보다 어려운딩

    // 길이 어두우면 가지 않는다.
    // 설치할 개수 M, 가로등 위치 x 로 결정
    // 높이만큼 주위를 비춤 - 최소한의 높이로 0~N 을 밝히고 싶음
    // 가로등은 모두 높이가 같아야 하고, 정수이다.
    public static void main(final String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        // 굴다리 길이 1 <= N <= 100 000
        // 5 ( 길이는 M )

        // 가로등 개수
        // 2

        // 가로등 위치
        // 2 4

        // 일종의 이분탐색...?

        // 10만 개를 전부 하나씩 검사하기에는 너무 비효율적일것
        // logN 으로 넣고

        // 적당히, 배열에 채워넣어서 모든 곳을 채우는지 검증하는 식?

        int n = Integer.parseInt(br.readLine());
        int m = Integer.parseInt(br.readLine());

        StringTokenizer st = new StringTokenizer(br.readLine());
        int[] ary = new int[n];
        for (int i = 0; i < m; i++) {
            ary[i] = Integer.parseInt(st.nextToken());
        }

        // 1개 일때는?
        // 높이가 고정 되어야 하는가...? 어려움

        int left = 1;
        int right = 100000;

        int answer = 100_000;

        while (left <= right) {
            int mid = (left + right) / 2;
//            System.out.printf("%s - %s - %s%n", left, right, mid);

            boolean[] light = new boolean[n + 1];
            // 최대 밝혀지는 범위
            int leftPos = 0;
            int rightPos = 0;

            for (int i = 0; i < m; i++) {
                // 가로등 위치
                int elementIndex = ary[i];

                // 왼쪽, 오른쪽 위치 보정
                int leftIndex = Math.max(elementIndex - mid, 0);
                int rightIndex = Math.min(elementIndex + mid, n);

                // 제일 처음은 그냥 설정
                if (rightPos == 0) {
                    // 제일 처음에 왼쪽이 0이 아니면 의미 없으므로 종료
                    if (leftIndex != 0) {
                        // 의도적으로 -1 변경 ( 밑에 check 메소드 절대 안돌게 )
                        leftPos = -1;
                        break;
                    }
                    rightPos = rightIndex;
                    continue;
                }

                // 현재 오른쪽보다, 왼쪽 인덱스가 작으면 변경
                // 즉, 빛이 서로 연결
                if (leftIndex <= rightPos) {
                    rightPos = rightIndex;
                }
            }

            // 모든게 다 켜지면? 줄인다.
            if (check(leftPos, rightPos, n)) {
                answer = Math.min(answer, mid);
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        System.out.println(answer);
    }

    // 시초?
    // 배열을 너무 비효율적으로 쓴다?
    // 가로등은 오름차순, 중복 X
    // 그냥 적절히 배열에 넣고, 배열의 요소들이 이어져 있는지 확인?
    // 1 - 3, 3 - 5, 5 - 7 과 같이

    // 또는 매번 적절히 잘 검사...?
    // 어차피 오름차순 -> 그래서 그 다음 요소의 값이 그전 요소보다 같거나 작지 않으면 불가능
    // -> 어두운 곳이 존재

    private static boolean check(int left, int right, int n) {
        return left == 0 && right == n;
    }
//    private static boolean check(boolean[] ary) {
//        for (int i = 0; i < ary.length; i++) {
//            if (!ary[i]) {
//                return false;
//            }
//        }
//        return true;
//    }
}
```
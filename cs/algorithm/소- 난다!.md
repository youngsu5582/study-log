# 소-난다!

- 문제 링크 : https://www.acmicpc.net/problem/19699

적절한 소수 최적 알고리즘은 기억해둘 필요가 있을듯

```java
// 18:34 - 19:06

static int n;
static int m;

public static void main(final String[] args) throws IOException {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

    int[] nm = Arrays.stream(br.readLine().split(" ")).mapToInt(Integer::parseInt).toArray();

    n = nm[0];
    m = nm[1];

    hArray = Arrays.stream(br.readLine().split(" "))
        .mapToInt(Integer::parseInt).sorted()
        .toArray();

    // n-m 만큼 해야 최소치를 보장
    // 5-3 = 2
    // 2 3 4 까지 해야 최소 3마리를 보장
    for (int i = 0; i <= n - m; i++) {
        List<Integer> ary = new ArrayList<>();
        dfs(ary, i);
    }

    StringBuilder sb = new StringBuilder();
    if (answers.isEmpty()) {
        System.out.println(-1);
        return;
    }
    for (Integer answer : answers.stream().sorted().collect(Collectors.toList())) {
        sb.append(answer).append(" ");
    }

    System.out.println(sb);

    // N 마리의 소
    // 소들의 몸무게 합이 소수가 되도록 M마리 소 선별
    // 나올 수 있는 몸무게의 합을 모두 출력

    // 1 <= M <= N <= 9
    // 1 <= Hi <= 1000

    // 결국 M 마리를 합쳐 소수가 나오게 되면 하는 것
    // 소수??

    // 적절한 dfs??
    // 순열
    // 값 오름차순 정렬 후 -> 앞에서 부터 추가
    // M 개가 되면 소수인지 확인후, 추가
}

private static int[] hArray;
private static Set<Integer> answers = new HashSet<>();

private static void dfs(List<Integer> array, int index) {
    if (array.size() == m) {
        int sum = array.stream().mapToInt(Integer::valueOf).sum();
        if (isPrime(sum)) {
            answers.add(sum);
        }
        return;
    }
    for (int j = index; j < n; j++) {
        array.add(hArray[j]);
        dfs(array, j + 1);
        array.remove(array.size() - 1);
    }
}

// 소수 어떻게 구하는지 명확한 방법이 안 떠오름...
// 적절하게 반 나누고, 하나라도 나눠지는거 같으면 그냥 반환
private static boolean isPrime(int num) {
    int temp = num / 2;
    for (int i = temp; i > 1; i--) {
        if (num % i == 0) {
            return false;
        }
    }
    return true;
}

// 더 효율적인 방법: 에라토스테네스의 체
// 2부터 N의 제곱근까지만 접근

private static boolean prime(int num) {
    // 2이하, 및 2 처리
    if (num < 2) {
        return false;
    }
    // 유일 짝수 소수
    if (num == 2) {
        return true;
    }
    // 그 다음 짝수는 절대 소수 될 수 없음 - 무조건 2로 나누어짐

    if (num % 2 == 0) {
        return false;
    }

    // 3부터 제곱근 까지 검사
    // 짝수는 이미 다 계산을 한 것이므로 +=2
    for (int i = 3; i * i <= num; i += 2) {
        if (num % i == 0) {
            return false;
        }
    }
    return true;
}
```
AWS 에서 관리하는 오브젝트 스토리지

- 파일 스토리지 : 파일을 계층 구조로 관리
    - 빠르게 찾고 업데이트 용이
    - 확장이 어려움
- 오브젝트 스토리지 : 오브젝트 단위(데이터,메타 데이터, 아이디) 관리
    - 정확한 경로 알아야 탐색 가능
    - 확장이 쉬움
    - 저렴함

위와 같이 사용 가능하다.

- 파일 저장하거나 활용하고 싶을 때
- static hosting 으로 서버 없이 제공하고 싶을 때 ( image, html, javscript )
- 기타 파일 관리 ( 서버가 100대 일 때 각 서버마다 리소스 가지는건 매우 비효율적 )

99.999999999% 내구성과 99.9% 가용성을 가진 분산 스토리지

> 내구성 : 파일을 잃어버리지 않을 확률 ( 9가 11개 일 시, 로또 당첨 확률의 1 / 122 라고 한다. )
> 가용성 : 원할 때 찾을 수 있는 확률

Standard 사용 시 최소 3개의 가용영역에 데이터를 분산 저장한다.

### 특징

- Presigned Url

이를 통해 서버를 거치지 않지만, 권한 있는 사용자만 접근 가능하게 할 수 있다.
-> Url 요청 시 파일 응답 or 파일 삽입 ( 서버는 단순 Url 반환 )

- 하나의 파일을 여러 버전으로 볼 수 있음

버저닝을 통해, 빠르게 변환 가능하다. `+` Soft Delete 가능

- 쓰기 일관성 보장

모든 요청이 같은 버전의 객체를 가져가도록 보장
( Upload 가 OK 되는 순간, 모든 요청이 해당 객체를 응답 받는다고 기대 가능 )

-> 강한 읽기 / 쓰기 일관성



## S3 로 이미지 사용하기

### MultipartFile

Spring MVC 에서 제공하는 인터페이스를 활용하는 방식
( `MultipartFile` 은 스프링에서 파일을 추상화한 형태 )

1. 서버에 Stream 형태로 전달
2. MutlipartFile 이라는 형태로 임시 디스크에 저장
3. S3에 다시 스트림으로 업로드

임시 디스크에 저장하므로 저장 공간이 부족하면?
`IOException : No space left on device` 와 같은 예외 발생시킨다.

```
spring.servlet.multipart:
max-file-size :
max-request-size :
file-size-threshold :
```

같은 요소를 통해 지정할 수 있다.

파일이 서버를 거쳐가기 때문에 큰 부하를 줄 수 있다!

- 서버 디스크 용량에 따라 실패할 수 있다
- 서버에 부하를 주는 방식이다

### Stream

서버를 바이패스 하는 형식으로 바로 S3 업로드
서버가 따로 저장하지 않고 전달

![[Pasted image 20250414221523.png]]

( CPU나 GC 결과가 매우 차이 남 )

근데, 실패할 가능성이 높아진다.

ConnectionpoolTimeoutException : 서버에서 S3 로 커넥션을 연결하지 못하고 타임아웃

서버에서 S3로 맺을 수 있는 커넥션이 제한되어 있었음
=> 클라이언트와 서버 네트워크 속도에 따라 의존된다.

### Presigned-URL

클라이언트가 직접 S3에 업로드 하는 방식

클라이언트       서버        S3

Pre-signed URL로 업로드 ->
Etag 응답 <-

클라이언트가 Etag 들을 모아서 complete 요청 -> 서버가 S3에 complete 요청

- 파일을 쪼개서 보내므로 훨씬 빠르게 보낼 수 있다.

![[Pasted image 20250414222108.png]]

#### 주의해야 할 점

- 우선 CORS 설정을 해줘야 함
  S3에서 클라이언트가 요청을 받을 수 있도록

- Pre-Signed URL 만료시간
  Pre-signed URL 이 시간이 지나면 효력을 잃도록 만료 시간을 설정해줘야 한다.
  ( 너무 짧게 잡으면 이미지 업로드에 지장, 너무 길게 잡으면 보안에 차질 )

- LifeCycle
  불안정한 파일이 쌓일 수 있음
  클라이언트가 4개 중 3개만 보내고, 1개를 보내지 않으면?
  -> 파일이 S3에 계속 쌓이게 된다!
  => 비용 청구가 늘어난다!

#### 단점

- 다소 복잡한 Flow
- S3 의존성

## 최적화

### 저용량, 고화질 이미지 포맷으로 변경

`webp` 는 -74%
`avif` 는 -90%
까지 용량이 감소됐다.

### 이미지 사이즈가 제각각

UI 요구사항 따라 필요한 이미지의 사이즈는 다름
- 배경 이미지
- 섬네일 이미지
  (`+` UI는 변경이 잦음 )

-> 요구사항에 맞게 사이즈를 리사이징 해서 응답

### 언제 어디에서??

#### 1. 이미지 업로드 및 최적화 작업 서버 도입

1. 별도 서버에 업로드
2. 서버가 이미지 최적화 해서 S3에 저장

사용자는 이제 CloudFront 통해서 이미지 요청 및 다운로드를 할 수 있다.

- presinged url 업로드 방식 사용할 수 없음
- 이미지 업로드와 최적화 작업에 대한 서버 구현
- 장애 발생 시, 재시도 및 롤백 구현
- 별도 서버 관리해야 하는 비용 발생

#### 2. 이미지가 업로드 되는 시점에 최적화

1. 사용자가 S3에 이미지 업로드 - Presigned URL 가능
2. 업로드 된 이벤트를 트리거로 람다 실행 : 람다가 이미지 최적화하고 S3에 사본 저장

사용자는 이제 CloudFront 통해서 이미지 요청 및 다운로드를 할 수 있다.

- AWS Lambda 활용한 서버리스
- 간단한 구현
- 이미지 요청 들어온 시점에, 사본이 생성되지 않을 수 있음 ( 사용자는 404 Not Found 응답 )
- 모든 이미지에 대해 사본 생성 ( UI 변경되어 새로운 사이즈 이미지가 필요하면? )

#### 3. 이미지 요청 시점에 최적화

1. 사용자가 S3에 이미지 업로드 - Presigned URL 가능

사용자는 이제 CloudFront 통해서 이미지 요청 및 다운로드를 할 수 있다.
   -> Lambda @ Edge 가 요청을 가로채서 이미지 최적화 작업 진행
   -> CloudFront 에 캐싱

- 사용자 요청에 정상 응답
- 사본 이미지 저장하지 않음
- 이미지 처음 요청하는 사용자는 긴 시간 대기
- CDN 에 캐싱되기 전에 최적화 작업이 여러번 반복

- 이미지 변경 요구사항으로, 대규모 캐시 미스 발생
- 동시에 많은 리사이즈 요청으로 이미지 변환 실패


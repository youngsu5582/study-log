# 단계별 파티셔닝

파티셔닝은 사실 매우 간단하다. ( 개념적인게 아니라, 적용만 보면 )

```sql
CREATE TABLE IF NOT EXISTS partition_entity
(
    LIKE partition_entity_prev INCLUDING ALL EXCLUDING INDEXES EXCLUDING IDENTITY
) PARTITION BY RANGE (created_at);
```

테이블을 만들때 `PARTITION BY` 옵션을 주면 된다.

- `LIKE partition_entity_prev` : partition_entity_prev 테이블의 모든 컬럼 정의를 복사
    - `INCLUDING ALL` : `DEFAULTS`, `CONSTRAINTS` ( PRIMARY, UNIQUE, FOREIGN 은 제외 ) 등도 복사
    - `EXCLUDING INDEXES` : 인덱스 제외, 파티셔닝 된 테이블은 파티셔닝 키를 포함해야 하므로, 인덱스가 달라짐
    - `EXCLUDIGN IDENTITY` : 자동 증가 칼럼 제외, 부모의 시퀸스를 공유 - id 의 유일성 보장

하지만, 파티션을 고려할 때는 기존 테이블에 데이터가 쌓여있고, 해야하는 경우가 대부분 일 것이다.
추가로, 파티션의 기준이 되는 created_at 칼럼에 인덱스가 없다면, 인덱스를 추가해야 한다.
-> 기존에 있는 인덱스가 복합 인덱스가 되어야 하는 경우도 존재

5천만개 가량의 데이에서 인덱스 설정하는데 5분 정도의 락이 걸린다.
그러면, 무중단 운영은 사실상 불가능하다.

이때, 파티셔닝을 단계적으로 적용해야 한다.

### 부모 테이블 생성

```sql
CREATE TABLE IF NOT EXISTS partition_table_parent
(
LIKE partition_table INCLUDING ALL EXCLUDING INDEXES EXCLUDING IDENTITY
) PARTITION BY RANGE (created_at);
```

이제,파티션을 적용될 새로운 테이블을 만들고

```sql
ALTER TABLE partition_entity
RENAME TO partition_entity_archive;

ALTER TABLE partition_entity_parent
  ALTER COLUMN id SET DEFAULT nextval('partition_entity_id_seq'::regclass);
```

기존 테이블 이름을 `partition_entity_archive`로 변경한다.
( 기존 테이블을 보존하기 위함 )

```sql
CREATE OR REPLACE VIEW partition_entity AS
SELECT *
FROM partition_entity_archive
UNION ALL
SELECT *
FROM partition_entity_parent;
```

그리고, 원래 테이블 이름으로 VIEW 를 선언한다.
( UNION ALL 을 통해, 두 테이블 합쳐서 보여줌 )

```sql
DO $do$
    DECLARE
        cutoff CONSTANT timestamp := now();
    BEGIN
        EXECUTE format($fmt$
        CREATE OR REPLACE FUNCTION trg_partition_entity_union_mod() RETURNS trigger AS
        $tg$
        DECLARE
            new_id BIGINT;
            _cutoff CONSTANT timestamp := TIMESTAMP '%s';
        BEGIN
            IF TG_OP = 'INSERT' THEN
                IF NEW.created_at < _cutoff THEN
                    INSERT INTO partition_entity_archive (partition_data, created_at) VALUES (NEW.partition_data, NEW.created_at)
                    RETURNING id INTO new_id;
                ELSE
                    INSERT INTO partition_entity_parent (partition_data, created_at) VALUES (NEW.partition_data, NEW.created_at)
                    RETURNING id INTO new_id;
                END IF;
                NEW.id := new_id;
                RETURN NEW;

            ELSIF TG_OP = 'UPDATE' THEN
                IF NEW.created_at < _cutoff THEN
                    UPDATE partition_entity_archive
                    SET
                      partition_data         = NEW.partition_data,
                        created_at         = NEW.created_at
                    WHERE id = OLD.id AND created_at = OLD.created_at;
                ELSE
                    UPDATE client_parent
                    SET
                      partition_data         = NEW.partition_data,
                        created_at         = NEW.created_at
                    WHERE id = OLD.id AND created_at = OLD.created_at;
                END IF;
                RETURN NEW;
            END IF;

            RETURN NEW;
        END;
        $tg$ LANGUAGE plpgsql;
    $fmt$, cutoff);
    END;
$do$ LANGUAGE plpgsql;
```

꽤나 복잡해 보일 수 있는데 간단하다.
cutoff 시점을 기준으로, INSERT 또는 UPDATE 가 발생했을 때,
해당 시점 이전이면 `partition_entity_archive` 테이블에, 이후면 `partition_entity_parent` 테이블에 데이터를 넣는다.

( cutoff 를 조절해, 일정 시점까지 archive 에 쌓이는걸 설정도 가능 )

```sql
DROP TRIGGER IF EXISTS trg_partition_entity_union_insert ON client;
CREATE TRIGGER trg_partition_entity_union_insert
INSTEAD OF INSERT
ON partition_entity
FOR EACH ROW
EXECUTE FUNCTION trg_prtition_entity_union_mod();

DROP TRIGGER IF EXISTS trg_partition_entity_union_update ON client;
CREATE TRIGGER trg_partition_entity_union_update
  INSTEAD OF UPDATE
  ON partition_entity
  FOR EACH ROW
  EXECUTE FUNCTION trg_prtition_entity_union_mod();
```

트리거를 선언해서, VIEW 에 INSERT 또는 UPDATE 가 발생했을 때, 위에서 만든 함수를 호출한다.

그리고, 나중에 이전 데이터들이 필요가 없어진다면 ( 예를 들어, 1주일이 지난 데이터는 필요 없다면 )

- 트리거 및 함수 제거
- union all 하는 작업 & VIEW 제거

를 통해 무사히 중단 없이 파티셔닝을 적용할 수 있다.

---

이때, 주의해야 할 점은 UNION ALL 을 하면서 성능이 조금 느려질 수 있다.
( 특히, 복잡한 WHERE 조건이 있는 경우 )

언제나 상황에 맞게 하도록 고려하자. ( 우리팀은 당장 이걸로 충분하다고 일단락..? )
---
tags:
  - 리팩토링
도서명: 객체지향의 사실과 오해
저자명: 조영호
---
> 유일하게 변하지 않는 것은 모든 것이 변한다는 사실 뿐이다


여행 중 길을 모른다면?

-> 지나가는 사람에게 마을까지 가는 길을 물어본다
-> 지도에 표시된 길을 따라간다

어떤 방법이든 상관없이 이동 가능하나 , 방법에 따라 찾는 과정과 난이도는 달라진다

첫 번째 방법은 '기능적이고 해결책 지향적 접근법' 이다

-> 가르쳐 주는 사람은 다른 마을까지 가는 경로를 단계별로 상세히 설명해야 한다
( 길을 따라 5km 정도 직진하면 강이 나오는데 , 건너지 말고 강둑 따라 ... )

- 일반적이지도 , 재사용 가능하지도 않다
- 중요 심볼이 없으면 설명하기 어려울 뿐 + 설명 만으로 경로 찾기 어렵다

두 번째 방법 지도는 지형을 기반으로 만들어진 추상화된 모델
-> '구조적이고 문제 지향적인 접근법'

-> 길을 찾는데 필요한 컨텍스트 정보가 함축되어 있다 ( 길을 묻는 방법보다 쉽고 간단 )

- 지도 상 현재 마을 위치 , 가고자 하는 마을 위치 찾은 후 길을 따라 연결하면 OK
- 특정 랜드마크를 통해 설명할 필요 없다

길을 묻는 방법은 현재 요구만 충족 가능하다 <-> 지도는 다양한 목적 위해 재사용 가능

왜 범용적일까?
-> 사람들이 원하는 '기능'에 비해 지도에 표시된 '구조'가 더 안정적이기 때문
( 대동여지도가 지금도 호환이 가능한 이유 ㅇ.ㅇ )

=> 기능이 아니라 구조를 기반으로 모델 구축하는게 더 범용적 & 이해하기 쉽고 & 변경에 안정적이라는 뜻

사람들의 요구사항은 계속 변하므로 기능 역시도 지속적으로 변할 수 밖에 없다
-> 기능 중심 접근법은 범용적이지 않고 재사용 불가능하고 변경에 취약해진다

안정적인 구조를 중심으로 기능을 종속시키면?
-> 구조 중심 접근법은 범용적이고 재사용 가능해진다
#### 기능 설계 VS 구조 설계

기능 측면 설게는 제품이 사용자를 위해 무엇을 할 수 있는지에 초점을 맞춘다

구조 측면 설계는 제품의 형태가 어떠해야 하는지 초점을 맞춘다

=> 기능 과 구조라는 두 가지 측면을 함께 녹여 조화를 이루도록 만드는 것이다!

SW 는 결국 사용자가 필요로 하는 기능을 제공해야 한다

-> 일차적 이유는 사용자에게 훌룡한 기능 제공 위해서
( 결국 금전적 대가를 지불하더라도 구매할 수 있도록 매력적이어야 함 )

훌륭한한 기능은 훌륭한한 소프트웨어를 만드는 충분조건
훌륭한한 구조는 훌륭한한 소프트웨어를 만들기 위한 필요조건

성공한 SW들은 공통적으로 훌륭한 기능 제공 과 동시에 새로운 기능 빠르고 안정적으로 추가 가능
( 요구사항이 변경되지 않는다면 개발자의 삶은 오히려 지루하지 않았을까? )

결국 설계라는 행위가 중요한 이유는 변경에 대한 필요성 때문이다

개발자의 삶이 고단하고 흥미로운 이유는?
-> 요구사항이 예측 불가능하게 변경되기 때문이다
=> 휼룡한 기능 제공 동시에 예측 불가능한 요구사항 변경에 유연하게 대처하는 구조를 제공해야 한다

⭐️ 미래에 대비하는 가장 좋은 방법은
변경을 예측하는 것이 아닌 변경을 수용할 수 있도록 선택의 여지를 설계에 마련해놓는 것
#### 두 가지 재료 : 기능과 구조

객체지향 세계를 구축하기 위해선
사용자에게 제공하는 '기능' 과 기능을 담을 안정적인 '구조' 라는 재료가 준비되어 있어야 한다

기능은 사용자가 자신의 목표를 달성하기 위해 사용할 수 있는 시스템 서비스
구조는 시스템의 기능을 구현하기 위한 기반 , 기능 변경을 수용할 수 있도록 안정적이어야 한다

일관되게 적용 가능한 두 가지 기법 발견
- 구조는 사용자나 이해관계자들이 도메인 에 관해 생각하는 개념 과 개념들 간 관계로 표현
- 기능은 사용자의 목표를 만족시키기 위해 책임을 수행하는 시스템 행위로 표현

기능을 수집하고 표현하기 위한 기법? -> 유스케이스 모델링
구조 수집하고 표현하기 위한 기법? -> 도메인 모델링
=> 각각의 결과물을 XXX 모델 이라고 함
#### 안정적인 재료 : 구조
##### 도메인 모델

모든 SW는 사용자의 필요성 충족시키기 위해 존재
병원? -> 모든 환자 진료 기록 보관 & 분석 위해 사용
은행? -> 소중한 자산 관리 & 보호 위해 사용

> 도메인이란 ? : 사용자가 프로그램을 사용하는 대상 분야

모델은 지식을 선택적으로 단순화 & 의식적으로 구조화한 형태 - 필요한 지식만 재구성
-> 현재 문제 관련된 측면만 추상화 하고 밖에 세부 사항은 무시하게 해준다

도메인 과 모델 정의를 통해 도메인 모델을 쉽게 정의 가능하다

도메인 모델은 프로그램 에서 사용하는 대상 영역 관한 지식을 선택적 & 단순화 하고 의식적 으로 구조화한 형태
( 영역 내 개념 , 개념 간 관계 , 다양한 규칙 or 제약 등을 주의 깊게 추상화 한 것 )

은행 업무 종사자? -> 은행 도메인은 고객 과 계좌 사이 돈의 흐름으로 이해
중고 자동차 판매상? -> 구매되는 자동차 , 판매되는 자동차의 교환으로 이해

도메인이 무엇이건 상관없이 항상 도메인 과 관련된 사람들이 도메인을 바라보는 모델이 존재한다

도메인 모델은 이해관계자들이 바라보는 멘탈 모델이다

> 멘탈 모델 : 사람들이 자기 자신 , 다른 사람 , 환경 , 자신이 상호작용하는 사물들에 대해 갖는 모형

> 제품을 설계할 때 제품 관한 모든 것이 사용자들이 제품에 대해 가지고 있는 멘탈 모델과 정확히 일치해야 한다 - 도널드 노먼

자신이 생각하는 것처럼 제품이 반응하고 움직일 것이라고 기대하기 때문
##### 도메인의 모습을 담을 수 있는 객체지향

도널드 노먼의 주장은 결국 최종 제품은 사용자의 관점을 반영해야 한다는 것
-> SW 개발에도 동일하게 적용 가능

결론적으로 객체지향을 이용하면
도메인에 대한 사용자 모델 , 디자인 모델 , 시스템 이미지 모두가
유사한 모습을 유지하도록 만드는 것이 가능하다 ( 연결 완전성 , 표현적 차이 라고 함 )
##### 표현적 차이

SW 객체는 결국 현실 객체에 대한 추상화가 아님!
-> 현실 객체를 모방하는게 아닌 은유를 기반으로 재창조한 세계

SW 객체는 현실 객체가 갖지 못한 특성을 가질 수도 , 현실 객체가 하지 못하는 행동을 할 수도 있다

현실 객체를 왜곡 하더라도 현실 객체의 특성을 토대로 구축된다
-> SW 객체와 현실 객체 사이 의미적 거리를 `표현적 차이 or 의미적 차이` 라고 한다

결국 가상 세계 창조 작업에서 현실 객체를 은유 하라는 목소리는 공허한 메아리 일 수 밖에 없다

투영해야 하는 대상은?
-> 바로 사용자가 도메인에 대해 생각하는 개념들 - SW 객체를 창조하기 위해 우리가 은유하는 대상이 <span style="color:#00b0f0">도메인 모델</span>

대상이 현실적인지 , 현실적이지 않은지에 상관없이 
도메인 모델을 통해 표현되는 도메인 객체들을 은유해야 한다

그렇기에 도메인 모델이 중요하다 ( 사용자가 도메인을 바라보는 관점을 그대로 코드에 반영하게 한다 )
-> 표헌작 차이를 줄어들게 하고 , 멘탈 모델이 코드에 녹아 스며들게 된다
##### 불안정한 기능을 담는 안정적인 도메인 모델

도메인 모델로 작성하는 두 번째 이유는 
도메인 모델이 제공하는 구조가 상대적으로 안정하기 때문이다

도메인 모델의 핵심은 사용자가 도메인을 바라보는 관점을 반영해 SW를 설계하고 구현

왜 사용자의 관점을 반영해야 할까?
-> 사용자들이 누구보다 도메인의 '본질적인' 측면을 가장 잘 이해하고 있으므로

본질적이라는 것은 변경이 적고 , 비교적 그 특성이 오랜 시간 유지된다는 것
-> SW 개발의 가장 큰 적은 변경이며 변경은 항상 발생한다는 사실임을 기억하자

사용자 모델에 포함된 개념 과 규칙은 비교적 변경될 확률이 적을 것이므로
사용자 모델 기반 설계와 코드를 만들면 변경에 쉽게 대처할 가능성이 커진다

결론적으로는 안정적인 구조를 제공하는 도메인 모델 기반으로
SW 구조를 설계하면 변경에 유연하게 대응하는 탄력적인 SW를 만들 수 있다

---

비록 도메인 모델이 도메인과 관련된 중요한 개념 , 관계를 보여준다 해도
실제로 사용자에게 중요한 것은 도메인 모델이 아니라 SW 기능이다

사용자에게 제공할 기능을 기술할 정보가 필요하다
-> 객체지향 커뮤니티에선 SW 기능을 기술하기 위해 유스케이스라는 기법을 사용해왔다
#### 불안정한 재료 : 기능
##### 유스케이스

기능적 요구사항이란 시스템이 사용자에게 제공해야 하는 기능의 목록을 정리한 것

기능을 제공해야 하는 이유는?
-> 사용자들이 시스템을 통해 달성하고자 하는 목표가 존재하기 때문

훌룡한 기능적 요구사항 얻기 위해선
목표 가진 사용자 와 사용자 목표 만족시키기 위해 일련 절차 수행하는 '상호작용' 관점에서 시스템을 바라봐야 함

-> 사용자는 자신 목표 달성하기 위해 시스템 과 상호작용을 시작하므로!

작업 요청하면 ? -> 시스템이 요청한 처리 후 원하는 결과 제공!

사용자 와 시스템 사이 상호작용은
사용자의 목표를 만족시키거나 에러 등 상호작용을 진행할 때 까지 계속되어야 한다

> 유스케이스 :  사용자의 목표를 달성하기 위해 사용자 - 시스템 간 이뤄지는 상호작용 흐름을 텍스트로 정리한 것

> 유스케이스는 시스템 이해관계자들 간 계약을 행위 중심으로 파악
> 액터라 불리는 행위자의 요청에 대한 시스템의 응답
> 
> 액터는 어떤 목표 달성 위해 시스템 과 상호작용 시작
> 시스템은 모든 이해관계자들의 요구에 응답하고 이해관계를 보호해야 한다

유스케이스 가치는 사용자들 목표를 중심으로
시스템의 기능적인 요구사항들을 이야기 형식으로 묶을 수 있다는 점

산발적으로 흩어져 있는 기능에 사용자 목표라는 문맥을 제공해 
각 기능이 유기적 관계를 지닌 체계를 이룰 수 있게 해준다

요구사항을 기억하고 관리하는 데 필요한 다양한 정신적 과부하를 줄이게 해준다

> 사용자 목표가 유스케이스의 핵심이다.
> 유스케이스는 공통의 사용자 목표를 통해 강하게 연관된 시나리오의 집합이다

```
유스케이스명 : 중도 해지 이자액을 계산한다

일차 액터 : 예금주

주요 성공 시나리오:

1. 예금주가 정기예금 계좌를 선택한다
2. 시스템은 정기예금 계좌 정보를 보여준다
3. 예금주가 금일 기준으로 예금을 해지할 경우 지급받을 수 있는 이자 계산을 요청한다
4. 시스템은 중도 해지 시 지급받을 수 있는 이자를 계산한 후 결과를 사용자에게 제공한다

확장:
	3a. 사용자는 해지 일자를 다른 일자로 입력할 수 있다
```
##### 유스케이스의 특성

1. 유스케이스는 다이어그램이 아닌 '텍스트'이다
-> 중요한 것은 상호작용 간의 흐름
-> 사용자와 시스템 간 상호작용을 일련의 이야기 흐름으로 표현하는 것이다

2. 유스케이스는 하나의 시나리오가 아닌 여러 시나리오들의 집합이다
-> 위 유스케이스는 2개의 시나리오를 포함 ( 예금주가 계좌 선택 후 당일 이자액 계산 , 계좌 선택 후 특정 일까지 이자액 계산 )
-> 이런 시나리오는 `유스케이스 인스턴스` 라고도 한다

3. 유스케이스는 단순 feature 목록과 다르다
-> feature 는 시스템이 수행해야 하는 기능 목록을 단순히 나열한 것 ( 시스템은 정기예금 정보를 보여준다 ... )
두 피처를 묶어 사용자와 상호작용 흐름 속에서 
두 피처를 포함하는 이야기 제공함으로써 시스템 기능에 대해 의사소통할 수 있는 문맥을 얻을 수 있다

4. 유스케이스는 사용자 인터페이스 와 관련된 세부 정보를 포함하지 말아야 한다
-> 위 유스케이스는 사용자가 해지 일자 선택 위해 사용자 인터페이스를 어떻게 구성하는지 정보가 포함되어 있지 않다


---
  tags:
  - 테스트
  도서명: "단위 테스트 : 생산성과 품질을 위한 단위 테스트 원칙과 패턴"
  저자명: 블라디미르 코리코프
  aliases:
  - Unit Testing Principles, Practices, and Patterns
---
### 단위 테스트 스타일

#### 출력 기반 테스트

SUT 에 입력을 넣고 , 생성되는 출력을 점검하는 방식

전역 상태 , 내부 상태를 변경하지 않는 코드에만 적용!
-> Side Effect 가 없다 + 작업 결과는 호출자에게 반환하는 것이 유일

함수형 프로그래밍 - 입력 과 출력이 동일하므로
#### 상태 기반 테스트

작업이 완료된 후 , 시스템 상태를 확인하는 것
( 상태는 SUT , 협력자 , 외부 의존성 등 모든 것의 상태를 의미 )

```java
var product =new Product("Hand Wash");
var sut = new Order();

sut.addProduct(product);

assertEquals(1,sut.product.count);
aseertEquals(product,sut.products[0]);
```

Products Collection 을 검증
#### 통신 기반 스타일

모킹을 사용해 대상 시스템 과 협력자 간 통신을 검증

```java
var emailGatewayMock = new Mock<IEmailGateway>();
var sut = new Controller(emailGatewayMock.Object);

sut.greetUser("user@gmail.com");

emailGatewayMock.verify( x => x.sendGreetingEmail("user@gmail.com"), Times.Once);
```

( 런던파는 통신 기반 스타일 보다 상태 기반 스타일 선호! )
#### 스타일 비교 
##### with 회귀 방지 , 피드백 속도 ?

###### 회귀 방지

- 테스트 중 실행되는 코드의 양
- 코드 복잡도
- 도메인 유의성
세 가지 특성으로 결정

보통 실행하는 코드가 많든 적든 원하는 대로 테스트 작성하기에 중요치 않다
###### 피드백 속도
사실 테스트 스타일 과 테스트 피드백 속도 사이에도 역시 상관관계가 거의 없다!
( 외부 의존성과 떨어져 있는 단위 테스트 영역 상 , 큰 차이 없음 )
##### with 리팩토링 내성 지표

상황에 따라 다름
-> 결국 , 리팩토링 중 발생하는 거짓 양성 수에 대한 척도
( 코드 구현 세부 사항에 결합된 테스트의 결과 )

- 출력 기반 테스트는 테스트 대상 메소드에만 결합
	-> 거짓 양성 방지가 가장 우수
	
- 상태 기반 테스트는 일반적으로 거짓 양성이 되기 쉬움
	-> 테스트 대상 메소드 외 클래스 상태와 함께 작동!

테스트가 제품 코드 간 결합도가 클수록 , 유출되는 구현 세부 사항에 테스트가 얽매이게 된다
( 큰 API 노출 영역에 의존하므로 , 구현 세부 사항과 결합될 가능성이 높아짐! )

- 통신 기반 테스트는 허위 경보에 가장 취약
	-> 테스트 대역으로 상호 작용 확인하는 테스트는 대부분 깨지기 쉬움 ( 스텁과 상호작용 하는 경우 )
해당 상호 작용 Side-Effect 가 외부 환경에 보이는 경우에만 Mocing 이 괜찮다
=> 통신 기반이 무조건 나쁘다는게 아님! ( 캡슐화를 잘 지키고 , 테스트 식별 가능 동작에만 결합하면 거짓 양성 최소로 줄일 수 있음 )
##### 유지 보수성 지표로 스타일 비교하기

단위 테스트 스타일과 밀접한 관련 있음
-> 리팩토링 내성과 달리 완화할 수 있는 방법이 많지 않음

- 테스트를 이해하기 얼마나 어려운가? ( 크기 , 복잡도 ... ) - 크면 파악 & 변경 어려워 유지보수도 어려워짐
- 테스트를 실행하기 얼마나 어려운가? ( 외부 의존성 개수에 대한 함수 ) - 서버 재부팅,  연결 문제 해결 등 시간 소요
두 가지 특성으로 정의

- 출력 기반 테스트는 가장 유지 보수하기 용이
	-> 항상 짧고 간결하므로 유지 보수 쉬움 ( 메소드의 입력 - 해당 출력 만 검증하면 되므로 )

애초에 외부 의존성을 다루지 않는다

- 상태 기반 테스트는 출력 기반보다 쉽지 않음
	-> 더 많은 공간을 차지 ( 코드 줄 길이 , 메모리 등등 )

```java
var now = new DateTime(2019,4,1);

sut.addComment(text,author,now);

assertEquals(1,sut.comments.count);
assertEquals(text,sut.comments[0].text);
assertEquals(author,sut.comments[0].author);
assertEquals(now,sut.comments[0].dateCreated);
```

댓글 추가한 후 , 댓글 목록에 댓글이 나타나는지 확인
( 댓글 하나에 , 검증부는 네 줄 ) -> 더 커지고 더 많아지면...?

물론 , 코드를 숨기고 테스트를 단축하는 헬퍼 메소드로 문제 완화는 가능
```java
sut.shouldContainNumberOfComment(1).withComment(text,author,now);
```
이런 메소드 작성 & 유지 에 상당한 노력 필요 - 재사용이 빈번히 되야만 명분이 생김 ( 몹시 드뭄 )

=> 결국 출력 기반보다 유지 보수성이 떨어짐

- 통신 기반 테스트는 가장 낮음
	-> 테스트 대역 과 상호 작용 검증 설정해야 함 ( 공간 많이 차지 )
##### 결론

|                   | 출력 기반 | 상태 기반 | 통신 기반 |
| :---------------- | :---- | :---- | :---- |
| 리팩토링 내성 지키기 위한 노력 | 낮음    | 중간    | 중간    |
| 유지비               | 낮음    | 중간    | 높음    |
항상 출력 기반 테스트를 선호하자
-> 말처럼 쉽지 않다

출력 기반 스타일은 함수형 스타일에 적용 가능 - 객체 지향 스타일에는 어려움

#### 함수형 프로그래밍

> 함수형 프로그래밍은 입력 에 따라 출력이 무조건 동일

사이드 이펙트를 비즈니스 연산 끝으로 몰아서 비즈니스 로직을 사이드 이펙트와 분리

두 가지 유형을 구분해 비즈니스 로직 - 사이드 이펙트를 분리하자

- 결정 내리는 코드 : 사이드 이펙트 필요 없기에 , 수학적 함수 사용해 작성 가능
- 해당 결정 따라 작용하는 코드 : 수학적 함수 의해 이뤄진 모든 결정을 DB 변경 or 메시지 버스 Message 같이 가시적 부분으로 변환

결정을 내리는 코드를 <span style="color:#00b0f0">함수형 코어</span> , 해당 결정 따라 작용하는 코드 <span style="color:#fb3c3c">가변 셸</span> 

- 가변 셸은 모든 입력 수집
- 함수형 코어는 결정 생성
- 셸은 결정을 사이드 이펙트로 변환
입력 -> 함수형 코어 -> 결정 

함수형 코어를 출력 기반으로 다루고 , 가변 셸을 훨씬 적은 통합 테스트에 맡기자

##### 함수형 VS 육각형

비슷한 점이 많다
- 둘 다 관심사 분리라는 아이디어 기반 
( 육각형 : 외부 애플리케이션 , 도메인 계층 분리 )
( 함수형 : 결정 과 실행 분리 )

- 의존성 간 단방향 흐름
( 육각형 : 도메인 계층 내 클래스는 서로에게만 의존 , 애플리케이션 서비스 계층 의존 X )
( 함수형 : 불변 코어는 가변 셸에 의존 X )

- 사이드 이펙트 처리부분이 다르다
( 육각형 : 모든 수정 사항은 도메인 계층 내 , 계층 경계를 넘을 수 없음 )
( 함수형 : 모든 사이드 이펙트를 불변 코어에서 비즈니스 연산 가장자리로 밀어냄 - 가변 셸이 처리 )

##### 리팩토링

기존 AuditManager 는 직접적으로 File System 과 연결되어 있음

- 테스트가 실행 흐름 방해할 수 있는 공유 의존성 존재
- 파일 시스템이 테스트를 느리게 함
- 로컬 , 빌드 모두 작업 디렉토리가 있고 테스트 할 수 있어야 하므로 유지 보수성 저하

=> 회귀 방지 Good , 리팩토링 내성 Good , 빠른 피드백 Bad , 유지 보수성 Bad

( 파일 시스템을 직접 작동하는 테스트는 통합 테스트에서 하자 )
###### IFileSystem Interface

인터페이스를 통해 파일 시스템에서 분리되므로
공유 의존성 사라지고 , 테스트 서로 독립적 실행 가능

=> 회귀 방지 Good , 리팩토링 내성 Good , 빠른 피드백 Good , 유지 보수성 Normal
###### 함수형

사이드 이펙트를 클래스 외부로 완전히 이동
-> AuditManager 는 파일에 수행할 작업을 둘러싼 결정만 책임짐 - 함수형 코어

Persister 가 결정 따라 파일 시스템 업데이트 적용 - 가변 셸

```java
return new FileUpdate(currentFile.fileName, newContent);
```

이처럼 업데이트 명령만 반환

```java
var sut = new AuditManager(3);
var files = new FileContent[]{
...
}
FileUpdate update = sut.AddRecord(
	files,"Alice",DateTime.parse("2019-04-06..."));
assertEquals("audit_3.txt",update.fileName);
assertEquals("Alice;2019-04...",update.newContent);
)
```

이렇게 명령을 테스트 함으로 Mocking 제거 가능!


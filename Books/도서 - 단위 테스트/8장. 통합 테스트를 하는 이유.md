---
  tags:
  - 테스트
  도서명: "단위 테스트 : 생산성과 품질을 위한 단위 테스트 원칙과 패턴"
  저자명: 블라디미르 코리코프
  aliases:
  - Unit Testing Principles, Practices, and Patterns
---
단위 테스트는 결국, 시스템이 전체적으로 잘 작동하는지 확신은 불가능하다
-> 비즈니스 로직을 확인하는 데 좋지만, 외부와 단절한 상태이므로

### 통합 테스트
#### 역활

단위 테스트는 세 가지 요구 사항을 충족해야 한다

- 단일 동작 단위 검증
- 빠르게 수행
- 다른 테스트와 별도 처리

하나라도 충족하지 못하는 테스트는 통합 테스트 범주에 속한다
=> 통합 테스트는 대부분 프로세스 외부 의존성과 통합해 어떻게 작동하는지를 검증
( 대체로 컨트롤러를 통해 다룸 )

> 애플리케이션은 목으로 대체할 수 없는 외부 의존성이 있다.
> ( 대개 데이터베이스이며, 다른 애플리케이션에서 볼 수 없는 의존성 )

추가로, 간단한 코드 - 지나치게 복잡한 코드 역시도 전혀 테스트 하지 말아야 한다
- 간단한 코드 : 노력을 들일 만한 가치가 없음
- 지나치게 복잡한 코드 : 알고리즘 & 컨트롤러 로 리팩토링 해야함
##### 테스트 피라미드

결국 단위 테스트 - 통합 테스트 간 균형 유지가 중요하다

통합 테스트는 외부 의존성 직접 작동하여 느려지며, 유지비가 많이 듬
- 프로세스 외부 의존성 운영 필요함
- 관련된 협력자가 많아서 테스트 비대해짐
=> 하지만 코드를(애플리케이션 & 라이브러리 코드) 더 많이 거치므로 회귀 방지 & 리팩토링 내성 우수

통합 테스트는 주요 흐름(happy case) 와 다루지 못하는 기타 예외 상황(edge case)를 다룬다

> 빠른 실패 원칙
> 
> 예기치 않은 오류 발생하자마자 현재 연산 중단
> - 피드백 루프 단축 : 버그 빨리 발견할수록 더 쉽게 해결 가능
>   지속성 상태 보호 : 버그는 애플리케이션 상태 손상 ( DB 단 침투시 고치기 더욱 어려워짐 )
#### 어떤 외부 의존성을 직접 테스트해야 하는가

외부 의존성은 두 가지 범주로 나뉜다
##### 관리 의존성 ( EX : DB )
- 전체를 제어할 수 있는 프로세스 외부 의존성, 애플리케이션을 통해서만 접근 가능
- 해당 의존성과 상호 작용은 외부 환경에서 볼 수 없음
##### 비관리 의존성 : SMTP 서버, 메시지 버스
- 해당 의존성과 상호 작용을 외부에서 볼 수 있음
- 다른 애플리케이션에서 볼 수 있는 사이드 이펙트 발생

=> 관리 의존성은 실제 인스턴스 사용하고, 비관리 의존성은 목으로 대체
##### 관리 의존성이며, 비관리 의존성인 경우는?

시스템 전용 DB로 시작 -> 다른 시스템이 DB의 데이터를 요구 -> 일부 테이블만 접근 권한 공유
=> 관리 의존성이며 비관리 의존성이 된다

이렇게 통합 구현에 DB 사용하면 시스템이 서로 결합 + 추가 개발을 복잡하게 만드므로 <span style="color:#fb3c3c">좋지 않다.</span> 
( API 나 메시지 버스를 사용하자 )
-> 다른 애플리케이션에서 볼 수 있는 테이블은 비관리 의존성으로 취급!
( 목을 사용해도 OK )
---
#### Example

통합 테스트는 일반적으로, 가장 긴 주요 흐름과 단위 테스트로는 수행할 수 없는 모든 예외 상황을 다루는 것
-> 가장 긴 흐름은 대체적으로 모든 프로세스 외부 의존성 거치는 것
( 사이드 이펙트 역시 가장 많음 )

EX : 기업 이메일 -> 일반 이메일로 변경하는 것
( DB에서 사용자와 회사 모두 업데이트 )
( 메시지 버스로 메시지 보냄 )
`public void changinig_email_from_corporate_to_non_corporate()`

DB는 접근할 수 없으므로 관리 의존성 -> 실제 인스턴스 사용
메시지 버스는 다른 시스템 과 통신 가능하게 하는 것 -> 목으로 대체
=> 프로세스 외부 의존성은 관리 의존성뿐 ( 나머지는 목으로 대체 )

```java
createUser(...);
createCompnay(...);
// 위 둘은 헬퍼 메소드

var messageBusMock = new Mock<IMessageBus>();
var sut = new UserController(db, messageBusMock.Object);
// 객체 생성

var result = sut.changeEmail(user.id,"new@Gmail.com");

assertThat(result).isTrue();

var userData = db.getUserById(user.id);
User userFromDb = UserFactory.create(userData);
assertThat(userFromDb.email).isEqualTo("new@gmail.com");
assertThat(userFormDb.type).isEqualTo(UserType.Customer);
// 사용자 상태 검증

// 회사 검증

messageBusMock.verify( x=> x.sendEmailChangedMessage(user.id,"new@gmail.com"),Times.Once);
//목 상호 작용 확인
```
#### 의존성 추상화 위한 인터페이스
##### 인터페이스와 느슨한 결합

DB나 메시지 버스 같은 외부 의존성을 위해 인터페이스를 도입
( 구현이 하나만 있는 경우에도 그럼! )
-> 오늘날 널리 퍼져 있어 아무도 의문 제기 X
```java
public interface IUserRepository {}
public class UserRepository implements IUserRepository {}
```

이렇게 하면?
- 프로세스 외부 의존성을 추상화해 느슨한 결합 달성
- 기존 코드 변경하지 않고, 새로운 기능 추가해 OCP 를 지킨다
이 두개가 확실한가???

단일 구현 위한 인터페이스는 추상화 X - 구체 클래스보다 결합도 역시 낮지 않다
( 진정한 추상화는 발견하는 것이지, 발명하는 것이 아님 )

YAGNI 원칙을 위반한다 - 향후 기능이 어떤지 설명을 위해 개발해서도, 수정해서도 안 된다!
- 기회 비용 : 담당자들에게 필요하지 않은 기능에 시간을 보내면, 필요한 기능을 제치고 시간 허비하는 것
- 프로젝트 코드가 적을 수록 좋음 : 코드베이스 소유 비용이 불필요하게 증가
##### 외부 의존성에는 왜 인터페이스를 사용하는가?

각 인터페이스에 구현이 하나만 있을때 외부 의존성에 인터페이스를 사용하는 이유??
-> 목을 사용하려고! ( 없으면 테스트 대역을 만들 수 없음 - 이 마저도 필요없으면 왜 써 ...?)

관리 의존성은 러에 명시적으로 주입 + 구체 클래스로 사용하자
( DB 역시 인터페이스가 굳이 필요하지 않다 )
#### 통합 테스트 모범 사례

- 도메인 모델 경계 명시
- 애플리케이션 내 계층 줄이기
- 순환 의존성 제거
=> 유익한 모범 사례가 코드베이스 상태 개선!
##### 도메인 모델 경계 명시

도메인 모델은 항상 코드베이스에 명시적이고 & 잘 알려진 위치에 두자!
-> 명시적 경계를 지정해 해당 부분을 더 잘 보여주고, 더 잘 설명할 수 있다

- 단위 테스트,알고리즘은 단위 테스트
- 컨트롤러는 통합 테스트
##### 계층 수 줄이기

간접 계층을 추가해 코드 추상화 & 일반화 하려함
-> 추상 계층이 너무 많으면, 탐색하기 어렵고 + 숨은 로직 이해하기 어려워진다

또한 모든 조각을 하나의 그림으로 만드는데 상당한 노력이 필요하다
=> 가능한 간접 계층을 적게 사용하자
( 대부분 백엔드 시스템은 도메인, 애플리케이션 서비스&컨트롤러, 인프라 계층 세 가지로 충분! )
 - 도메인 계층 : 도메인 로직 포함
 - 애플리케이션 서비스 계층 : 외부 클라이언트 진입 점, 도메인 클래스 - 외부 의존성 간 작업 조정
 - 인프라 계층 : DB 저장소, ORM 매핑, SMTP 게이트웨이
##### 순환 의존성 제거하기

> 순환 의존성은 둘 이상 클래스가 제대로 작동하고자 직&간접적으로 서로 의존하는 것

```java
public class CheckOutService {
	public void checkOut(int orderId) {
		var service = new ReportGenerationService();
		service.generateReport(orderId,this);
	}
}

public class ReportGenerationService {
	public void generateReport(int orderId,CheckOutService checkOutService){
	...
	checkoutService.complete();
	}
}
```

순환 의존성 코드는 읽고 이해하려 할 때 알아야 할 것이 너무 많아 부담이 된다
( 하나의 클래스를 이해하려면 주변 클래스 그래프 전체 이해 요구 )

테스트 역시 매우 힘듬
-> 동작 단위를 하나 분리하려면 인터페이스 통해 목 처리
-> 이 역시도 컴파일 타임에 순환 참조는 제거하나, 런타임에는 순환 존재

=> 순환 의존성을 모두 제거하는 것은 불가능 할 수 있음 - 그래프를 가능한 작게 만들어 손상 최소화!
##### 다중 실행 구절 사용

두 개 이상 준비, 실행, 검증 구절을 두는 것은 코드 악취에 해당
-> 여러 가지 동작 단위를 확인 해 유지 보수성을 저해

```
준비 : 사용자 등록 필요 데이터 준비
실행 : registerUser 호출
검증 : 등록이 성공적 완료인지 확인 위해 DB 조회
실행 : deleteUser 호출
검증 : 삭제 됐는지 확인 위해 DB 조회
```

상태가 자연스럽게 흐르고, 첫 번째 실행이 두 번째 실행의 준비 단계 역활도 가능!
-> 테스트가 초점을 잃고 순식간에 커질 수 있다

각 실행은 고유 테스트로 추출해 테스트를 나누는 것이 좋다
( 불필요 할 수 있으나, 장기적으로 유리 )

예외로, 원하는 상태로 만들기 어려운 외부 의존성으로 작동하는 테스트

사용자 등록 -> 외부 은행 시스템에서 은행 계좌 만들어줌
은행에서 제공하는 샌드박스가 너무 느리거나 호출 수를 제한 한다면?
-> 여러 동작 하나의 테스트로 묶어 외부 의존성에 대한 상호 작용 횟수를 줄여야 한다

#### 로깅 기능 테스트

로깅은 자체가 회색 지대
-> 테스트를 어떻게 해야 할지 조차 분명하지 않음

- 로깅을 조금이라도 테스트 해야 하는가?
- 그렇다면 어떻게 테스트해야 하는가?
- 로깅이 얼마나 많으면 충분한가?
- 로거 인스턴스를 어떻게 전달할까?

로깅은 애플리케이션 동작에 대한 중요한 정보 생성
-> 로깅은 너무 보편적이므로 테스트 노력을 들일 가치가 있는지 분명하지 않다

그렇기에, 로깅이 식별할 수 있는 동작인지, 구현 세부 사항인지 구별해야 한다
-> 로깅은 텍스트 파일,DB 같은 프로세스 외부 의존성에 사이드 이펙트 초래!
=> 개발자 이외의 사람이 본다면, 반드시 테스트 <-> 개발자만 본다면 자유로이 수정 가능한 구현 세부 사항

- 지원 로깅 : 지원 담당자, 시스템 관리자가 추적할 수 있는 메시지 제공
- 진단 로깅 : 개발자가 애플리케이션 내부 상황 파악하도록 돕는다
##### 어떻게 테스트해야 하는가?

로깅에 프로세스 외부 의존성 있으므로 동일 규칙 적용
-> 상호 작용 검증하려면 목을 써야 함
###### ILoggger 위 래퍼 도입

하지만, 목으로 처리하지는 말자
지원 로깅은 비즈니스 요구 사항!
-> 코드베이스에 명시적 반영
-> 비즈니스 필요한 모든 자원 로깅 명시적 나열하는 특별한 DomainLogger 를 만들고 상호작용 확인
```java
_domainLogger.userTypeHasChagned(){
	userId,type,newType);
}

---

public class DomainLogger() {
	public void userTypeHasChanged(int userId,UserType oldType,UserType newType) {
		logger.info("User "+userId+" chagned type " ...);
	}
}
```

도메인 언어 사용해 비즈니스에 필요한 특정 로그 항목 선언
-> 지원 로깅 더 쉽게 이해 + 유지 보수 가능
###### 구조화된 로깅 이해

로그 데이터 캡처 & 렌더링을 분리하는 로깅 기술
```java
logger.info("User Id is "+12);
```

전통적인 로깅 - 구조상 결과 로그 파일 분석이 어렵다
-> 구조화된 로깅은 로그 저장소에 구조가 있다

템플릿 해시를 계산해 해당 해시를 입력 매개변수와 결합해 캡처 데이터 세트 형성
-> 그 후, 데이터 렌더링 - JSON,CSV,파일 로 렌더링하게 설정 가능 

```java
public class User {
	public void changeEmail(string newEmail, Company compnay) {
		if(type != newType) {
			addDomainEvent(new UserTypeChangedEvent(userId,type,newType));
		}
		...
	
		addDomainEvent(new EmailGhangedEvent(userId,newEmail));
	}
}
```
두가지 도메인 이벤트 존재 - 같은 인터페이스 (IDomainEvent) 를 구현하므로, 같은 컬렉션 저장 가능

```java

public class UserController {
	public String changeEmail(){
		...

		_eventDispatcher.dispatch(user.domainEvents);
	}
}
```

EventDispatcher는 도메인 이벤트를 외부 의존성에 대한 호출로 변환해준다
- userTypeChangedEvent -> domainLogger.userTypeHasChanged() 변환
=> 지원 로깅을 테스트하는게 다른 비관리 의존성 ( 메시지 버스 ) 테스트하는 것과 다르지 않다

컨트롤러에서 지원 로깅이 필요할 시? -> 도메인 이벤트 사용할 필요 X - 의존성 분리를 위해 이벤트를 사용한다
( UserController 는 DomainLogger 직접 사용 가능 )
##### 로깅이 얼마나 많으면 충분한가?

최적의 로그 분량은 어느정도일까?
지원 로깅은 비즈니스 요구 사항이므로, 당연히 수행 해줘야 함
진단 로깅은 결국 과도하게 사용하지 않는 것이 중요하다
- 과도한 로깅은 코드를 혼란스럽게 한다( 특히, 도메인 모델 해당 ) -> 코드 모호
- 로그의 신호 대비 잡음 비율이 중요⭐️
	-> 많은수록, 관련 정보 찾기 어려워진다
	-> 신호를 최대한으로 늘리고, 잡음 최소한으로 줄여라

도메인 모델에서 진단 로깅을 절대 사용하지 않게 하자
-> 컨트롤러로 안전하게 옮기자 + 무언가를 디버깅 할때만 일시적 진단 로깅 사용!
-> 이상적 처리되지 않은 예외에 대해서만 진단 로깅을 사용하자


---
  tags:
  - 테스트
  도서명: "단위 테스트 : 생산성과 품질을 위한 단위 테스트 원칙과 패턴"
  저자명: 블라디미르 코리코프
  aliases:
  - Unit Testing Principles, Practices, and Patterns
---
단위 테스트에는 런던파 , 고전파 라는 2가지의 견해가 존재한다
### 단위 테스트 정의

- 작은 코드 조각(단위)을 검증
- 빠르게 수행
- 격리된 방식 처리하는 자동화된 코드

대중의 의견이 크게 다른 것은 세 번째 속성

#### 격리 문제 in 런던파

테스트 대상 시스템을 협력자 ( collaborator ) 에게서 격리하는 것
-> 다른 클래스들에 의존하면 모든 의존성들을 테스트 대역으로 대체!!

=> 동작을 외부 영향과 분리해 테스트 대상 클래스에만 집중하게 하자

##### 이점
- 테스트가 실패하면 테스트 대상만 시스템이 고장 났음을 보장한다!
( 클래스 모든 의존성이 테스트 대역으로 대체되었으니까 ) - 이는 한 번에 한 클래스만 테스트 하는걸 보장

- 객체 그래프를 분할 가능하다!
모든 클래스가 각각 직접적 의존성을 가지고 , 의존성이 연결되어 상당히 복잡할 수 있음
( 순환 의존성이 포함될 수도 있음! )
-> 테스트 대역을 사용해 , 상호 연결 객체 그래프를 분할 가능하다!

#### 고전파 Example

```java
public void 인벤토리가_충분하면_결제에_성공한다(){
	// Given , 준비
	var store = new Store();
	store.addInventory(Product.Shampoo, 10);
	var customer = new Customer();

	// When , 실행
	boolean success = customer.purchase(store,Product.shampo, 5);

	// Then , 검증
	assertTrue(success);
	assertEquals(5,store.getInventory(Product.Shampoo));
}
```
준비 부분은 의존성 (Store) 과 테스트 대상 시스템 (Customer) 모두 준비해야한다
> 테스트 대상 시스템 ( System Under Test , SUT )
> 테스트 대상 메소드 ( Method Under Test , MUT )
> 흔히 동의어로 아나 , MUT 는 메소드 <-> SUT 는 클래스 전체

두 가지 이유로 , 협력자 필요
- 테스트 대상 메소드 컴파일 하려면 Store 인스턴스 필요
- 검증 단계에서 Purchase 결과로 상점 제품 수량이 감소할 가능성이 존재

협력자를 대체하지 않고 , 운영 ( Production ) 인스턴스 사용
-> Customer 와 Store 둘 다 효과적 검증
-> Customer 가 올바르게 작동해도 Store 내부 버그가 있으면 단위 테스트에 실패할 수 있다
( 두 클래스가 서로 격리되어 있지 않으므로 )
#### 런던파 Example

```java
public void 인벤토리가_충분하면_결제에_성공한다(){
	var storeMock = mock(IStore.class);
	storeMock
		.setup( x => x.hasEnoughInventory(Product.Shampoo, 5))
		.return(true);
	var customer = new Customer();

	boolean success = customer.purchase(storeMock.Object,Product.Shampoo,5);

	assertTrue(success);	
	verify(storeMock,times(1)).hasEnoughInventory(Product.Shampoo,5);
}
```

준비 단계에서 실제 인스턴스가 아닌 내장 클래스를 통해 대체
Store 상태 수정 대신 , 메소드 호출에 어떻게 응답하는지 직접 정의
( 이때 , Stroe 자체 Class 대신 Interface 를 통해 만든다 - Class 는 안티 패턴 )

##### VS 고전파

고전파는 상점 상태를 통해 검증
런던파는 Customer 와 Store 간의 상호 작용을 검사한다
( + 호출 횟수 까지 검증 )

### 격리 문제 대한 고전파의 접근

결국 격리를 시킨다는 것은
여러 클래스를 한 번에 테스트 해도 괜찮다는 것이다
( 테스트가 서로 소통하고 실행 컨텍스트 단에 영향 줄 수도 있음 )

어떤 테스트 준비 단계에서는 고객 생성
어떤 테스트 준비 단계에서는 고객 삭제
=> 병렬 실행시 테스트 간 간섭 때문에 Fail 발생!

#### 의존성

공유 의존성은 테스트 간 공유 , 서로 결과에 영향 미치는 수단 제공 의존성
( 정적 가변 필드 - static mutable field , DB )

비공개 의존성은 공유하지 않는 의존성

프로세스 외부 의존성은 Application 실행 프로세스 외부에서 실행되는 의존성
대부분 공유 의존성에 해당되나 모두 그런 것은 아님
( DB는 프로세스 외부 이며 공유 의존성 )

=> 단위 테스트에서 서로 격리 하라는 것은 SUT 에서 공유 의존성만 격리 하라는 것

휘발성 의존성은 두 가지 속성 중 하나를 나타내는 의존성
- 기본 설치된 환경 외 런타임 환경 설정 & 구성 요구 ( DB , API 서비스 등등 )
- 비결정적 동작 : 난수 생성기 or 현재 날짜 & 시간 반환 클래스 - 각 호출 대해 다련 결과 제공하기 때문
( 공유 의존성가 비슷하나 다름 , 파일 시스템은 공유이나 휘발성 X , 난수 생성기는 휘발성이나 공유 X )

=> 단위가 반드시 클래스에 국한될 필요가 없다 ( 공유 의존성 없는 한 여러 클래스 묶어서 단위 테스트 가능 )

### 단위 테스트

런던파 : 격리 주체를 <span style="color:#00b0f0">단위</span> 로 , 단위 크기를 <span style="color:#00b0f0">단일 클래스</span> 로 , 테스트 대역 사용 대상을 <span style="color:#00b0f0">불변 의존성 외 모두 의존성</span> 으로!
고전파 : 격리 주체를 <span style="color:#00b0f0">단위 테스트</span> 로 , 단위 크기를 <span style="color:#00b0f0">단일 클래스 or 클래스 세트</span> 로 , 테스트 대역 사용 대상을 <span style="color:#00b0f0">공유 의존성</span> 으로!

런던파는 공유 의존성 과 비공개 의존성 중 변경 가능한 의존성을 교체 대상으로 접근
고전파는 공유 의존성만을 교체 대상으로 접근

##### 협력자 VS 의존성

협력자는 공유 하거나 변경 가능한 의존성 ( DB는 공유 의존성이므로 DB접근 권한 클래스를 협력자 )
`custoer.purchase(store, Product.shampoo,5)`

Product 와 5는 의존성이나 협력자는 아님 ( 값 또는 값 객체로 분류 )
store 만 협력자

### 고전파 - 런단파 비교

핵심은 단위 테스트 정의에서 격리 문제를 어떻게 다루는지! ( 이는 테스트 해야할 단위와 의존성 취급 방법으로 넘어감 )
-> 화자는 고전파 방식을 선호

#### 런던파 접근 방식의 이점

- 입자성이 좋음 - 테스트가 세밀해 한 번에 한 클래스만 확인
- 서로 연결된 클래스 그래프가 커져도 테스트 하기 쉬움 - 모든 협력자가 테스트 대역으로 교체
- 테스트가 실패했으면 어떤 기능이 실패했는지 확실한 인지 가능

#### 화자의 런던파 이점에 대한 반박 
##### 한 번에 한 클래스만 테스트하기
좋은 입자성에 대한 요점은 단위 테스트에서 단위 구성에 대한 논쟁부터 시작
런던파는 클래스를 단위로 간주
-> 테스트는 코드의 단위를 검증해선 안 된다! 
-> 동작의 단위 , 문제 영역에서 의미 없는 것이 아닌 비즈니스 로직 등을 검증해야 함 ( 클래스가 많아도 OK )

`우리집 강아지를 부르면 , 바로 나에게 온다 ` VS `우리집 강아지를 부르면 왼쪽 앞다리르 움직이고 , 이어서 오른쪽 앞다리를 움직이고...`
##### 상호 연결된 클래스의 큰 그래프를 단위 테스트하기
실제 협력자 대신해 모킹을 사용하면 클래스를 매우 쉽게 테스트 가능하다
( 복잡한 의존성 그래프 들을 끊어내므로 )

고전파는 결국 SUT 를 설정하려면 전체 객체 그래프를 다시 생성해야 함
-> 대부분의 클래스 그래프가 커진 것은 코드 설계 문제의 결과
-> 대역으로 그래프를 끊어낸다고 해결이 되는게 아님!
##### 버그 위치 정확히 찾아내기
런던파 테스트는 시스템에 버그가 생기면 , SUT에 버그가 포함된 테스트만 실패한다
( 고전파는 오작동 클래스를 참조하는 테스트들 역시도 실패! )
하나의 버그가 전체 시스템에 걸쳐 테스트 실패를 야기하는 파급 효과를 초래한다
-> 크게 우려할 문제 X ( 정기적 , 변경 마다 테스트를 실행하면 쉽게 원인 파악 가능 )
-> 많은 테스트 결함으로 이어진다면 , 방금 고장 낸 코드 조각이 큰 가치가 있음을 보여줌

#### TDD 시스템 설계 방식의 차이

런던파는 단위 테스트를 하향식 TDD 로 진행 ( 기대치를 설정하는 상위 테스트 부터 시작 )
-> 대역을 사용해 예상 결과 달성하고 통신해야 하는 협력자 지정
-> 지정한 협력자들을 하나식 구현해나감 ( 한 번에 한 클래스에만 집중할 수 있으므로 가능 )

고전파는 단위 테스트를 상향식 TDD 로 진행 ( 도메인 모델부터 시작해 최종 사용자가 사용할 때 까지 계층을 위에 둠 )


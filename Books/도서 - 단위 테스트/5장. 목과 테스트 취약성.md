---
  tags:
  - 테스트
  도서명: "단위 테스트 : 생산성과 품질을 위한 단위 테스트 원칙과 패턴"
  저자명: 블라디미르 코리코프
  aliases:
  - Unit Testing Principles, Practices, and Patterns
---
#### 테스트 대역 유형

- 테스트 대역 : 모든 유형의 비운영용 가짜 의존성
목 과 스텁이라는 두 가지 유형으로 나뉨

- 목 : Mocking , Spy
외부로 나가는 상호 작용 모방 & 검사하는 데 도움 ( SUT 가 상태 변경 위한 의존성 호출 )
-> SMTP 서버는 외부 나가는 상호 작용 - 사이드 이펙트 O

- 스텁 : Stub , Dummy , Fake
내부 들어오는 상호 작용 모방 도움 ( SUT가 입력 데이터 얻기 위한 의존성 호출 )
-> DB 는 내부로 들어오는 상호 작용 - 사이드 이펙트 X 

다섯 가지의 차이점은 결국 미미한 구현 사항 차이

- 스파이는 목과 유사하나 , 목은 Mocking 프레임워크에 도움 받음
- 더미는 널 , 가짜 문자열 같은 단순 & 하드코딩 된 값 ( 메소드 매개변수 등에 사용 )
- 스텁은 더 정교함 ( 시나리오마다 다른 값을 반환하게 필요한 것을 갖춘 완벽한 의존성 )
- 페이크는 보통 아직 존재하지 않는 의존성을 대체하고자 구현

목은 SUT 와 의존성 간 상호 작용을 모방 & 검사
스텁은 모방만 함

#### 도구로서의 Mock VS 테스트 대역로서의 Mock

```java
var mock = new Mock<IEmailGateway>();
var sut = new Controller(mock.Object);

sut.greetUser("user@gmail.com");

mock.verify(x -> x.SendGreetingEmail("user@gmail.com"), Times.Once);
```

- Mock 클래스는 테스트 대역 만들 수 있는 도구로서의 Mock
- mock 인스턴스는 테스트 대역으로서의 Mock

```java
var stub = new Mock<IDatabase>();
stub.setup(x -> x.getNumberOfUsers()).returns(10);
var sut = new Controller(stub.Object);

Report report = sut.createReport();

assertEquals(10, report.numberOfUsers);
```

- stub 은 내부로 들어오는 상호 작용 , SUT에 입력 데이터 제공 호출 모방

도구 Mock 과 테스트 대역 mock 을 구분하자

##### 스텁으로 상호 작용을 검증하지 말자

스텁 으로 호출은 SUT가 생성하는 최종 결과가 아님! 
-> 취약한 테스트 야기하는 안티 패턴

```java
mock.verify(x -> x.SendGreetingEmail("user@gmail.com"));
```

해당 결과는 비즈니스 담당자가 시스템에 하길 원하는 값 -> 검증 해야 함!

```java
stub.setup(x -> x.getNumberOfUsers()).returns(10);
```

해당 내용은 데이터 수집 방법에 대한 내부 구현 세부 사항
-> 결과만 올바르다면 검증할 필요 X

```java
stub.verify(x -> x.getNumberOfUsers(),Times.Once);
```

최종 결과가 아닌 사항 검증하는 관행
-> 과잉 명세

#### 목과 스텁은 명령 - 조회에 어떻게 관련되어 있는가?

목 과 스텁은 명령 조회 분리 (CQS) 원칙과도 관련이 있음!

> CQS
> 모든 메소드는 명령 or 조회여야 하며
> 혼용 되어서는 안 된다!
> 명령 : 사이드 이펙트 일으킴 + 반환 값 X
> 조회 : 사이드 이펙트 X + 반환 값 O
> 
> 물론 , stack.pop 처럼 CQS 원칙을 따를 수 없는 것 역시 존재

명령을 대체하는 테스트 대엽은 Mock
조회를 대체하는 테스트 대역은 Stub

sendGreetingEmail 은 이메일을 보내는 사이드 이펙트 존재하는 <span style="color:#00b0f0">명령</span> 
getNumberOfUsers 는 값 반환하고 DB 상태 변경하지 않는 <span style="color:#fb3c3c">조회</span> 

### 식별할 수 있는 동작 과 구현 세부 사항

결국 최종 결과만을 검증하고 
구현 세부 사항 과 테스트를 가능한 떨어뜨리는게 핵심
( "어떻게" 가 아닌 "무엇" 에 중점을 둬야 함 )

#### 식별할 수 있 동작 != 공개 API

제품 코드는 2차원으로 분류 가능

- 공개 API or 비공개 API
- 식별할 수 있는 동작 or 구현 세부 사항

각 차원 범주는 서로 겹치지 않음
( 식별할 수 있는 동작이 public or private 둘다 가능 하다는 말 )

-> 클라이언트가 목표 달성하는 데 도움이 되는 연산을 노출 ( 계산 수행 or 사이드 이펙트 초래 or 둘다 )
-> 클라이언트가 목표 달성하는 데 도움이 되는 상태를 노출 ( 상태 : 시스템 의 현재 상태 )
( 구현 세부 사항은 두 가지 중 아무것도 하지 않음 )

이상적으로는 
- 공개 API 와 식별할 수 있는 동작 일치해야함
- 구현 세부 사항은 클라이언트 눈에 보이지 않는 비공개여야함
##### 구현 세부 사항 유출 : 연산 예
```java
public class UserController {
	public void renameUser(int userId,String newName) {
		User user = 디비_검색_아이디(userId);

		String normalizedName = user.normalizeName(newName);
		user.name = normalizedName;

		디비_저장(user);
	}
}
```
(UserController 가 클라이언트 코드 )
속성 과 메소드 둘다 공개

- 클라이언트가 목표 달성하는 데 도움이 되는 연산을 노출
- 클라이언트가 목표 달성하는 데 도움이 되는 상태를 노출

해당 두 가지를 속성하는 값은?
-> Name 속성

```java
public class User {
	private String normalizeName(String name) {
		String result = name.trim();

		if(result.length() > 50)
			return result.subString(0,50);
		return result;
	}
}

public void renameUser(int userId,String newName) {
		User user = 디비_검색_아이디(userId);
		user.name = newName;
		디비_저장(user);
}
```

식별할 수 있는 동작만 공개 , 구현 세부 사항은 비공개 API에 은닉
###### 잘 설계된 API + 캡슐화

캡슐화는 결국 불변성 위반 하는 모순 방지 조치

구현 세부 사항을 노출하면 불변성 위반 가져옴 -> 캡슐화 역시 제대로 유지 불가능

장기적으로 코드베이스 유지 보수에는 캡슐화가 중요 ( 복잡도 때문 )
-> 복잡해질수록 작업하기 더 어려워짐 + 개발 속도 느려짐 + 버그 수 증가
=> 캡슐화 만이 대처할 수 있는 실질적 방법

할 수 있는 것과 할 수 없는 것을 구분하는 것이 매우 중요함
-> 코드 변경 시 모순이 생기지 않게 많은 정보를 염두에 둬야 함
-> 프로그래밍 프로세스에 정신적 부담 증대
-> 실수할 가능성을 최대한 없애주는게 캡슐화를 올바르게 유지!
=> 지속적인 성장을 가능하게 해주는 것

- 구현 세부 사항을 숨기면 클라이언트 시야에서 클래스 내부 가릴 수 있으므로 내부 손상 위험이 적음
- 데이터 - 연산 결합시 해당 연산이 클래스 불변성 위반하지 않도록 할 수 있음
##### 구현 세부 사항 유출 : 상태 예

```java
public class MessageRenderer {
	public ReadOnlyList<IRenderer> subRenderers;

	public String render(Message message) {
		return ...
	}
}
```

멤버 변수가 public 일시 구현 세부 사항 유출
좋은 단위 테스트 와 잘 설계된 API 사이에는 본질적 관계 존재!
-> 세부 사항 비공개로 하면 테스트가 식별 동작 검증하는 것 외 다른 선택지 불가능
=> 리팩토링 내성 역시 자동으로 좋아짐!

|     | 식별할 수 있는 동작 | 구현 세부 사항 |
| :-- | :---------- | :------- |
| 공개  | 좋음          | 나쁨       |
| 비공개 |             |          |
### 육각형 아키텍처

전형적인 애플리케이션은 도메인 - 애플리케이션 서비스 두 계층으로 구성

- 도메인 계층은 애플리케이션 중심부 ( 비즈니스 로직 포함 )
- 애플리케이션 서비스 계층은 도메인 계층 위에 위치 ( 외부 환경과 통신 조정 )
-> REST API 일시, API 대한 모든 요청이 애플리케이션 서비스 계층에 도달
-> 도메인 클래스 - 외부 의존성 간 작업 조정
( DB 조회 , 해당 데이터로 도메인 인스턴스 구체화 )
( 해당 인스턴스에 연산 호출 )
( 결과 DB에 다시 저장 )

##### 도메인 계층 - 애플리케이션 서비스 계층 간 관심사 분리

도메인 계층이 비즈니스 로직에 대해서만 책임을 져야 한다 - 다른 모든 책임에서 제외
외부 애플리케이션 통신 or DB 책임은 애플리케이션 서비스에 귀속 되어야 한다
##### 애플리케이션 내부 통신

애플리케이션 서비스 계층에서 -> 도메인 계층으로 단방향 의존성 이여야 한다
도메인 계층 내부 클래스는 도메인 계층 내부 클래스 끼리만 서로 의존
( 애플리케이션 서비스 계층은 도메인 계층에 대해 알지만 , 도메인 계층은 완전히 격리 )
##### 애플리케이션 간 통신

외부 애플리케이션은 애프리케이션 서비스 계층에 있는 인터페이스를 통해 연결
아무도 도메인 계층에 직접 접근 불가능

잘 설계된 API는 `fractal` 특성이 있다
> 전체 계층 만큼 크든 , 단일 클래스만큼 작든 똑같이 적용

-> 이는 테스트도 프랙탈 구조를 갖게 해준다
(달성 목표는 같지만 서로 다른 수준에서 동작 검증 )

식별할 수 있는 동작은 바깥 -> 안쪽으로 흐른다
-> 재귀적 추적 가능!

공개 API 를 항상 비즈니스 요구 사항 따라 추적해나가자
( 유틸리티 , 인프라 코드에는 적용 X - 너무 낮은 수준 or 세밀한 수준 )
#### 시스템 내부 통신 , 시스템 간 통신

- 시스템 간 통신 : 다른 애플리케이션 과 통신하는 것 
-> 클라이언트 목표와 직접적 관계 X
-> 협력과 결합하면 테스트가 취약해진다

목을 사용하면 시스템 - 외부 애플리케이션 간 통신 패턴 확인할 떄 좋음
##### Example

- 고객이 상점에서 제품을 구매하려 한다
- 매장 내 제품 수량이 충분하면?
	-> 재고가 상점에서 줄어듬
	-> 고객에게 이메일로 영수증 발송
	-> 확인 내역 반환

- 시스템 간 통신 : 서드파티 애플리케이션(외부에서 들어오는 클라이언트) , 이메일 게이트웨이
- 시스템 내부 통신 : Customer , Store 간 통신

SMTP 서비스에 대한 호출을 Mocking 으로 할 시?
-> 리팩토링을 겪어도 통신 유형이 그대로 유지! ( 테스트 취약성 야기 X )
```java
var mock = new Mock<IEmailGateway>();

mock.verify(
	x => x.sendReceipt("customer@email.com", "Shampoo", 5), Times.Once
);
```
##### 결론

런던파는 모든 의존성에 Mocking 사용을 권장 + 시스템 내 통신 , 시스템 간 통신을 구분하지 않는다
-> 구현 세부 사항에 결합되어 테스트가 리팩토링 내성이 없어지게 된다

고전파는 테스트 간 공유 의존성 ( SMTP 서비스 , 메시지 버스 등 프로세스 외부 의존성 )만 Mocking
( 고전파가 Mocking을 싫어하는게 아님! - 필요한 곳에서만 사용하자 )

하지만 , 고전파는 공유 의존성을 최대한 피할 것을 권고
-> 실행 컨텍스트를 서로 방해하고 , 병럴 처리를 할 수 없기 때문!

>테스트 격리 : 테스트를 병렬적 , 순차적 또는 임의 순서로 실행하는 것

공유 의존성이 내부에 있다면? -> 각 테스트 실행 시 해당 의존성을 새로 만들어 재사용성 피하기 쉬움
공유 의존성이 외부에 있다면? -> 테스트 실행 전 인스턴스화 or 공유 해야 함 ( 현저히 느려짐 )

- 외부 의존성이 애플리케이션 통해서만 접근이 가능하다면?
	-> 시스템에서 식별할 수 있는 동작이 아님

통신 패턴을 항상 지켜야 하는 요구 사항은
하위 호환성에서부터 비롯되므로 외부 시스템과 통신하는 방식을 지켜야 함 ( 동시에 변경할 수 없으므로 )

외부 시스템에 대한 프록시 같은 역활 하고 , 클라이언트가 직접 접근할 수 없다면?
-> 하위 호환성 요구 사라짐
( 같이 배포할 수 있으므로 영향을 미치지 않음 , 통신 패턴이 단순 구현 세부 사항이 되어버림 )

애플리케이션 DB는 클라이언트 시야에서 완전히 숨어있음
-> 다른 저장 방식으로 대체 가능
-> 완전히 통제권을 가진 프로세스 외부 의존성을 Mocking 하면 오히려 깨지기 쉬워짐
=> 테이블 분할하거나 저장 프로시서 매개변수 타입 변경할 떄마다 테스트가 빨간색이 되는걸 원하지 않음

사이드 이펙트가 외부 환경에서 보일 때만 Mocking을 사용하자!


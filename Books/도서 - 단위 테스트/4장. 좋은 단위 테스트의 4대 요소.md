---
  tags:
  - 테스트
  도서명: "단위 테스트 : 생산성과 품질을 위한 단위 테스트 원칙과 패턴"
  저자명: 블라디미르 코리코프
  aliases:
  - Unit Testing Principles, Practices, and Patterns
---
### 좋은 단위 테스트의 4대 요소

- 회귀 방지
- 리팩토링 내성
- 빠른 피드백
- 유지 보수성

-> 어떤 자동화된 테스트 ( 단위 테스트 , 통합 테스트 , E2E ) 도 분석 가능

#### 회귀 방지

>회귀 : 코드를 수정한 후 ( 새 기능 출시 후 ) 기능이 의도한 대로 작동하지 않는 경우

이런 회귀는 매우 귀찮음 유발
-> 개발할 기능이 많을 수록 새로운 릴리스에서 기능이 하나라도 고장 날 가능성이 높으면 매우 최악!

=> 회귀에 대한 효과저인 보호책을 개발하는게 매우 중요

다음 사항들을 고려하자

- 테스트 중 실행되는 코드의 양

일반적으로 실행되는 코드 많을수록
테스트에서 회귀가 나타날 가능성이 높음 - 코드가 생성하는 결과가 유효한지도 역시 확인해야함

- 코드 복잡도
- 코드의 도메인 유의성

복잡한 비즈니스 로직을 나타내는 코드가 보일러플레이트 보다 훨씬 더 중요하다
( 단순한 코드 테스트 하는 것은 가치가 거의 없다 - 짧고 , 비즈니스 로직을 많이 담고 있지도 않음 )

작성하지 않은 코드 ( 라이브러리 , 프레임워크 , 외부 시스템 ) 도 중요하다
-> 테스트가 해당 내용들도 테스트 범주에 포함해 의존성에 대한 검증이 올바른지 확인하자

#### 리팩토링 내성

테스트를 Fail로 바꾸지 않고 기본 애플리케이션 코드를 리팩토링 할 수 있는지 대한 척도

리팩토링시 아무 것도 고장이 나지 않았는데 , 테스트가 Fail 이 됐다면?
-> 거짓 양성! ( 실제 기능은 의도 대로 작동하지만 , 테스트는 실패를 나타내는 결과 )
=> 적을 수록 좋다

거짓 양성은 전체 테스트 스위트에 치명적 영향을 줄 수 있기 때문
-> 단위 테스트 목표인 프로젝트 성장을 지속 가능하게 하는 것에 어긋남

거짓 양성 빈번하면 테스트 스위트에 대한 신뢰 서서히 떨어지며 , 믿을 만한 안전망으로 인식 X
-> 신뢰가 부족해지면 리팩토링 줄여듬 ( 회귀 피하려고 코드 변경 최소한 )

> 양치기 소년은 왜 죽었는가?
##### 무엇이 거짓 양성의 원인인가?

거짓 양성의 수는 테스트 구성 방식과 직접적 관련이 있다

테스트 와 SUT 의 구현 세부 사항이 많이 결합될수록 허위 정보가 더 많이 생김
-> 세부 사항을 테스트에서 분리해 거짓 양성에 대한 가능성을 줄여나가자
=> 테스트가 최종 결과를 검증하는지 확인해야 함

즉 , 테스트가 실패하면 이야기 와 실제 애플리케이션 동작이 분리되어 실패하게 만들자

무엇이 잘못 됐는지 빨리 이해하게 도움이 된다
( 다른 실패는 중요한 것으로부터 주의를 돌리려는 소음일 뿐 )
##### 구현 세부 사항 대신 최종 결과를 목표로

테스트를 깨지지 않게 하고 리팩토링 내성을 높이려면
SUT 구현 세부 사항 과 테스트 간 결합도를 낮추어 나가야함

- 좋지 않은 거짓 양성은 컴파일 오류를 내지 않는 것 - 처리하기 까다로워짐
#### 첫 번째 특성 과 두 번째 특성 간 본질적 관계

둘 다 정반대 관점에서도 테스트 스위트 정확도에 기여

두 가지 특성은 시간이 흐려며 프로젝트에 영향을 다르게 미치는 경향이 있다
( 프로젝트 시작 직후에는 당연히 회귀 방지를 휼룡하게 갖춤 , 리팩토링 내성은 바로 필요하지 않음 )

##### 테스트 정확도 극대화

- 거짓 음성(2종 오류) : 기능이 고장이여도 테스트가 통과하는 경우
	-> 회귀 방지가 도움이 된다
- 거짓 양성(1종 오류) : 기능이 작동해도 테스트가 실패하는 경우
	-> 리팩토링 내성이 도움이 된다

두 내성은 테스트 스위트 정확도를 극대화 하는 것을 목표로 함

- 테스트가 버그 있음을 얼마나 잘 나타내는가
- 테스트가 버그 없음을 얼마나 잘 나타내는가

테스트 정확도 = 신호 ( 발견된 버그 수 ) / 소음 ( 허위 경보 발생 수 )

신호 증가 : 회귀를 더 잘 찾아내는 테스트로 개선
소음을 줄이는 것 : 허위 경보 발생시키지 않는 테스트로 개선

##### 거짓 양성 - 거짓 음성의 중요성 : 역학 관계

단기적으로는 거짓 양성도 거짓 음성 만큼 나쁘지 않음 ( 거짓 음성이 처음부터 나쁘다는 뜻 )

리팩토링이 바로 중요하지 않음! ( 초기엔 코드 정리 X , 기억 속 생생함 )
-> 시간이 흐를수록 코드 베이스는 나빠짐 ( 복잡하고 , 체계적이지 않게 된다 )
-> 정기적으로 리팩토링을 해야만 함 ( 새로운 기능에 드는 비용이 갈수록 커짐 )
=> 테스트에서 리팩토링 내성이 점점 더 중요해진다

( 회귀 방지는 결국 성장을 유지하는 데 도움을 줌 )

##### 세 번째 & 네 번째 요소 : 빠른 피드백 과 유지 보수성

빠른 피드백은 사실상 필수 속성
-> 테스트 속도 빠를수록 더 많은 테스트 수행 & 더 자주 실행!
( 피드백 루프를 대폭 줄여 , 버그를 수정하는 비용을 0에 가깝게 줄일 수 있음 )

유지 보수성 지표는 유지비를 평가한다

- 테스트가 얼마나 이해하기 어려운가 :
테스트 크기와 관련 ( 코드 라인이 적을수록 더 읽기 쉬우므로 )
-> 단지 라인 수를 압축하려고 인위적 압축은 X
=> 테스트 코드의 품질은 제품 코드 만큼 중요하게 하자 ( 일급 시민 취급 )

- 테스트가 얼마나 실행하기 어려운가 :
프로세스가 외부 종속성으로 작동하면 의존성 상시 운영에 시간을 들여야 함
( DB 서버 재부팅 , 네트워크 연결 문제 해결 등등 )

### 이상적 테스트를 찾아서

결국

- 회귀 방지
- 리팩토링 내성
- 빠른 피드백
- 유지 보수성

이 4가지 특성을 곱해 테스트의 가치 결정!
( 어떤 특성이라도 0이 되지 않게 노력해야 함 - 물론 측정 기준치는 X )
#### 이상적인 테스트를 만들 수 있는가?

모두 1로 유지 하는건 불가능!
-> 회귀 방지 - 리팩토링 내성 - 빠른 피드백은 상호 배타적!
( 셋 중 하나를 희생해야 나머지 둘을 최대로 가능 )
##### 극단적 사례 : E2E 테스트

최종 사용자 관점에서 시스템 살펴봄
-> UI , DB , 외부 애플리케이션 포함한 모든 시스템 구성 요소 테스트

- 많은 코드 테스트 하므로 회귀 방지 OK
- 거짓 양성에 면역이 되므로 리팩토링 내성 OK ( 리팩토링은 결국 식별 동작을 변경하지는 않으므로 )
- 느린 속도로 빠른 피드백 X
##### 극단적 사례 : 간단한 테스트

너무나도 단순해 고장 날 것 없는 작은 코드 조각이라면?
```java
var user = new User();
user.setName("Joy Son");
assertEquals(user.name,"Joy Son");
```

- 매우 빠르게 실행 , 빠른 피드백 O
- 거짓 양성 역시 생길 가능성이 매우 낮으므로 리팩토링 내성 O
- 기반 코드가 실수할 여지는 많으므로 회귀 방지 X

-> 결국 , 테스트는 이름만 바뀔 뿐 동어 반복 테스트만 불러옴
##### 극단적 사례 : 깨지기 쉬운 테스트

```java
public void GetById_Executes_correct_SQL_code(){
	var sut = new UserRepository();

	User user = sut.getById(5);

	assertEquals(
	"SELECT * FROM dbo.[User] WHERE UserID = 5",마지막_SQL_문);
}
```

실행이 빠르고 , 회귀를 잡을 가능성이 높지만 거짓 양성이 많은 테스트

```
SELECT UserID , Name , Email , FROM dbo.[User] WHERE UserID = 5
```

SQL 문을 여러가지 형태로 변경 or 받는 값을 추가해도 바로 테스트가 깨짐
##### 결론

세 가지 특성 모두 완벽 점수를 얻어 이상적 테스트를 만드는 것은 불가능

모두 조금씩 양보하는 게 최선의 전략인가?
-> 실제로는 리팩토링 내성을 최대한 많이 가지는 것을 목표로 해야 함
( E2E 테스트만 쓰거나 , 테스트가 상당히 빠르지 않는 한 )
=> 회귀 방지 와 빠른 피드백 사이에서 trade-off 를 해야 한다

리팩토링 내성을 포기할 수 없는 이유는
대부분 해당 특성 여부가 이진 선택이기 때문! ( 리팩토링 내성이 있거나 없거나 둘 중 하나 )

결국 테스트 종류들은 회귀 방지 와 빠른 피드백 사이에 있다
- E2E : 회귀 방지 Good , 빠른 피드백 Bad
- 통합 : 회귀 방지 Normal , 빠른 피드백 Normal
- 단위 : 회귀 방지 Bad , 빠른 피드백 Good
( 어느 계층도 리팩토링 내성을 포기 X )

대부분 애플리케이션이 비즈니스 규칙 or 기타 복잡도 없는 CRUD 작업일 시?
-> 단위 테스트 - 통합 테스트 의 수는 같고 , E2E 없는 직사각형 모습

외부 의존성이 DB 하나일 시?
-> E2E 테스트가 더 용이할 수 있음 ( 매우 빠르게 동작하므로 ) ,
통합 테스트와 구별은 불가능

#### 블랙 박스 , 화이트 박스 테스트

- 블랙 박스 : 시스템 내부 구조 몰라도 , 시스템 기능 검사 가능 - 회귀 방지 Bad , 리팩토링 내성 Good
명세 , 요구 사항 을 통해 무엇을 해야 하는지 구축

- 화이트 박스 : 내부 작업 검증 - 회귀 방지 Good , 리팩토링 내성 Bad
소스 코드에서 파생

화이트 박스가 더 철저함 ( 소스 코드 분석 시 , 외부 명세에만 의존할 때 놓치는 많은 오류 발견 가능 )
-> But , 깨지기도 쉬움 ( 특정 구현과 결합되어 있으므로 )
=> 리팩토링 내성 과 타협할 수 없으므로 블랙 박스 테스트를 선택하자!
( 테스트를 통해 비즈니스 요구 사항으로 거슬러 올라갈 수 없다면 , 테스트가 깨지기 쉬움을 나타낸다 )


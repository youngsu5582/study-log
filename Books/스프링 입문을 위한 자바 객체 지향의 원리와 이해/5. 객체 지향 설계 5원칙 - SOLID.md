---
tags:
  - 스프링
도서명: 스프링 입문을 위한 자바 객체 지향의 원리와 이해
저자명: 김종민
---
결국 이 원칙들은 응집도는 높이고 결합도는 낮추라는 고전 원칙을 재정립 한 것!

- 결합도 : 상호 의존 정도, 낮으면 모듈 간 상호 의존성 저하 ->  수정,유지보수 용이
- 응집도 : 하나의 모듈 내부 존재 구성 요소들의 기능적 관련 -> 높으면 하나의 책임 집중 + 독립성 높아짐 -> 수정,유지보수 용이

### SRP - 단일 책임 원칙

> 어떤 클래스를 변경해야 하는 이유는 오직 하나뿐이여야 한다. - 로버트.C.마틴

남자라는 클래스가 있다면..?
```
							남자
여자친구 -> ( 남자친구 역활 )  기념일 챙기기()
어머니 ->   ( 아들 역활 ) 효도 하기()
```

남자의 할일이 너무 많다!

만약 여자친구랑 헤어져서 남자친구 역활을 할 필요가 없다면?

```
							남자친구
여자친구 -> ( 남자친구 역활 )  기념일 챙기기()

							아들
어머니 -> ( 아들 역활 )  효도 하기()
```

단순히 클래스의 분할만 생각하면 안된다!
-> 속성, 메소드, 모듈, 패키지, 컴포넌트, 프레임워크 등등 모든 곳에 접목 가능하다

```java
class 사람 {
	String 군번;
}

사람 로미오 = new 사람();
사람 줄리엣 = new 사람();

줄리엣.군번 = "123xxx" - ???
```

속성이 SRP 를 지키지 못한 경우
-> 불필요한 if문과 실수를 유발할 수 밖에 없다
( 사실상, DB의 정규화도 단일 책임 원칙의 일환 )
```java
void 소변보다(){
	if(this.성별 == 수컷){
		//한쪽 다리 들고 소변을 본다
	}
	// 뒷다리 두개를 굽혀 앉은 자세로 소변을 본다.
}
```

메소드가 SRP를 지키지 못한 경우
-> 메소드가 단일 책임을 지키지 못한 경우 나타나는게 if 문!
```java
abstract class 강아지 {
	abstract void 소변보다();
}
class 수컷강아지 extends 강아지 {
	void 소변보다() {
		//한쪽 다리를 들고 소변을 본다.
	}
}
```

=> 단일 책임 원칙과 가장 관계가 깊은 것은 모델링 과정 담당하는 <span style="color:#00b050">추상화</span> 
### OCP - 개방 폐쇠 원칙

> 소프트웨어 엔티티(클래스,모듈,함수)는 확장에 대해서는 열려 있어야 하나, 변경에 대해선 닫혀 있어야 한다. - 로버트.C.마틴

자동차가 교체 되었다고, 창문 수동 개방 & 기어 수동 조작에 대해 전부 새로 알아야 되는가?
-> 영향을 받지 않는다!

```java
public interface 자동차 {
	void 창문개방();
	void 기어조작();
}
```

다양한 자동차가 생긴다 하더라도
자동차 입장에서는 자신의 확장에는 개방 + 운전자 입장에서는 주변의 변화에 격리 !!
( jdbc 는 JDBC Interface 를 통해 사용 + interface 를 구현한 Driver 들은 변경 가능 )

자바 역시 OCP 의 산물
-> 개발자는 프로그램이 Window,Linux,Mac 에서 구동될지 신경 쓰지 않는다
-> JVM 이 OCP 를 준수하게 해준다 ( + 상속 도 )

=> Spring 은 결국, 개방 폐쇠 원칙의 산물!!
### LSP - 리스코프 치환 원칙

> 서브 타입은 언제나 자신 기반 타입으로 교체할 수 있어야 한다. - 로버트.C.마틴

상속은 결국, 조직도(계층도)가 아닌 분류도가 되어야 한다

- 하위 클래스 is a kind of 상위 클래스 - 하위 분류는 상위 분류의 한 종류다
- 구현 클래스 is able to 인터페이스 - 구현 분류는 인터페이스 할 수 있어야 한다

```java
아버지 춘향이 = new 딸(); // ❌
동물 뽀로로 = new 펭귄(); // ✅
```

> 하위 클래스 인스턴스는 상위 객체 참조 변수 대입해 상위 클래스 인스턴스 역활 하는데 문제가 없어야 한다. - 의역
### ISP - 인터페이스 분리 원칙

> 클라이언트는 자신이 사용하지 않는 메소드에 의존 관계를 맺으면 안 된다. - 로버트.C.마틴

SRP 에서는 남자 클래스를 남자친구/아들 역활로 토막내서 하나의 역활을 하게 분할했다

ISP 는 남자 클래스를 토막내는게 아닌 역활을 분리!
-> 어머니와 있을 때는 아들 인터페이스로 제한, 여자친구와 있을 때는 남자친구 인터페이스로 제한

인터페이스를 통해 메소드를 외부에 제공할때는 항상 최소한의 메소드만 제공해야 한다
-> 남자친구 인터페이스에는 사격하기() 메소드를 제공할 필요도 없고, 해서도 안된다
-> 그 역활이 가져야만 하는 메소드만 제공하자

![350](https://i.imgur.com/5MYIF7T.jpeg)

-> 상위 클래스는 풍성할수록 좋다.
-> 인터페이스는 작을수록 좋다.
=> 불필요한 형변환을 없앤다.

데이트 중 사격하기 실시하는 소대원이자 남자친구?

=> 인터페이스는 역활에 충실한 최소한의 기능만 공개하자 ( ~ is able to )
### DIP - 의존 역전 원칙

> 고차원 모듈이 저차원 모듈에 의존하면 안된다. -> 두 모듈 다른 추상화된 것에 의존해야 한다
> 구체적인 것이 추상화된 것에 의존해야 한다
> - 로버트.C.마틴

자동차가 스노우 타이어에 의존한다면?
-> 스노우 타이어를 일반 타이어로 교체할때, 자동차는 영향에 노출 되어 있다.

자동차가 타이어에 의존한다면?
-> 추상화된 인터페이스에 의존하므로, 타이어가 변경돼도 자동차는 영향 받지 않는 형태로 구성
( 이는 OCP 원칙에도 포함 -> 결국 서로가 융화되어 있음 )

자신보다 변하기 쉬운 것에 의존하던 것을 추상화된 인터페이스에 의존 관계를 역전시키자

> 자신보다 변하기 쉬운 것에 의존하지 마라 - 의역

상위 클래스, 인터페이스, 추상 클래스 일수록 변하지 않을 가능성이 높다.
### 정리 

SOLID 는 결국 객체 지향을 올바르게 녹여내기 위한 원칙
-> 객체 지향 4대 특성을 제대로 활용한 결과로 나타난 당연한 것!

SoC 를 지키면 이 모든 SOLID 도 준수된다. - Seperation Of Concerns

관심이 같은 것끼리 하나의 객체 안으로 or 친한 객체로 모으고
관심이 다른 것은 가능한 따로 떨어져 서로 영향 주지 않도록 분리하라는 것

SOLID 원칙을 적용하면, 소스 파일 개수는 더 많아지는 경향이 있다.

많아진 파일이
논리를 더욱 잘 분할하고, 잘 표현하기에 이해하기 쉽고, 개발하기 쉽게 해준다!


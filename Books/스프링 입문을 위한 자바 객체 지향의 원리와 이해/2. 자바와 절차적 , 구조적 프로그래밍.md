---
tags:
  - 스프링
도서명: 스프링 입문을 위한 자바 객체 지향의 원리와 이해
저자명: 김종민
---
자바 세계는 결국 현실 세계를 모방하고 있다

하드웨어 - 물리적 컴퓨터 => JVM ( 자바 가상 기계 )
운영체제 => JRE ( JVM 용 OS )
소프트웨어 개발 도구 => JDK ( JVM 용 SW 개발 도구 )

JDK 는 자바 소스 컴파일러 javac 포함
JRE 는 자바 프로그램 실행기 java 포함

### 자바에 존재하는 절차적/구조적 프로그래밍의 유산

goto 는 결국 절차지향의 어마어마한 폐해 
( java 에서는 goto 를 사용하지 못하게 키워드 선점해놓음 )

goto 를 사용하게 되면, 프로그램 실행 순서가 너무 복잡해질 수 있다
-> 논리적으로 잘 구성하면 모두 피할 수 있는 것

구조적 프로그래밍은 함수를 권장 - 중복 코드 방지, 논리를 함수 단위로 분리
구조적 프로그래밍은 공유 사용시 문제 발생 방지 위해 지역 변수 권장

Function 과 Method 가 뭐가 다를까?
-> 화자 입장에서 전혀 다르지 않다
( 절차/구조적 프로그래밍에서 함수라 불렀는데 좀 다르게 불러야 하지 않을까? => Method )

### 자바 프로그램은 어떻게 실행되는가?
```java
public class Start {
	public static void main(String[] args) {
		System.out.println("Hello OOP!!");
	}
}
```

JRE 가 우선, main 메소드가 있는지 확인
-> 프로그램 실행 위한 사전 준비 착수 ( JVM 에 전원을 넣어 부팅 )
-> 부팅된 JVM이 목적 파일 받아 목적 파일 실행
-> JVM 이 가장 먼저 java.lang 패키지를 스태틱 영역에 할당
-> 그후, 개발자가 작성한 모든 클래스 & 패키지 스태틱 영역에 할당
=> 여기까지가 <span style="color:#00b050">전처리</span> 

메소드의 놀이터는 stack
-> main() 스택 프레임이 스택 영역에 할당 ( 여는 중괄호 `{`)
-> 메서드 인자 args 저장 변수 공간을 스택 프레임 맨 밑에 확보해야 함
=> 그 후, main 메소드 안 첫 명령문 실행
( 구문 실행 시에는 T 메모리에 변화 X - 코드 실행 공간은 별도 존재하므로 )

닫는 중괄호 `}` 로 스택 프레임 소멸
-> main() 메소드 스택 프레임 소멸
-> JRE 는 JVM 종료
-> JRE 자체도 운영체제 상 메모리 해제

### 변수 와 메모리
```java
public class Start {
	public static void main(String[] args) {
		int i;
		i = 10;

		double d = 20.0;
	}
}
```

main 메소드 스택 프레임에 밑에서부터 차곡차곡 쌓이게 된다
`<메소드 스택 프레임>`
i `?`  => 10 으로 변경!
args `[]`

- i를 초기화 하지 않으면 `Variable 'i' might not have been initialized` 라고 뜬다
-> 해당 공간 메모리 사용한 프로그램이 청소하지 않은 쓰레기 값을 그대로 가지고 있게 된다
### 블록 구문과 메모리

```java
public class Start3 {
	public static void main(String[] args) {  
	    int i = 10;  
	    int k = 20;  
	  
	    if (i == 10) {  
	        int m = k + 5;  
	        k = m;  
	    } else {  
	        int p = k + 10;  
	        k = p;  
	    }  
	}
}
```

if 조건에 따라 분기를 일으킨다
`<main 메소드 스택 프레임>`
k 20
i 10
args `[]`
=>
`<main 메소드 스택 프레임>`
	`<if(true) 스택 프레임`
		m ? => 25 로 변경
k 20
i 10
args `[]`
#### 지역 변수

스택 영역에서 일생을 보냄

외부 스택 프레임에서, 내부 스택 프레임의 변수 접근은 불가능
내부 스택 프레임에서, 외부 스택 프레임 변수 접근은 가능
( if 문 내부에서는 외부 변수 접근 가능 <-> if 문 외부에서는 if 문 내부 변수 접근 불가능 )

```java
public static void main(String[] args) {  
    int k = 5;  
    int m;  
    m = square(k);  
}  
private static int square(int k) {  
    int result;  
    k = 25;  
    result = k;  
    return result;  
}
```

해당 코드에서 왜 square 는 main 메소드의 값을 접근하지 못할까?

1. 이치에 맞기 때문 : 메소드는 서로의 고유 공간 -> 서로 침범하면 문제 유발 가능
2. 포인터 문제 : square 메소드에서 main 메소드의 m을 알려면 변수 메모리 위치를 알아야만 함
3. 실전에선 사용 메소드가 다양한 곳에서 호출되므로 : 결국 포인터를 주고받을수 밖에 없음

메소드를 호출하며 인자 전달하는 것은 변수 자체가 아닌, 변수의 값만 복제해서 전달
-> 값에 의한 전달 ( Call By Value )
=> 메소드 사이 값 전달 or 반환하는 방법은 메소드의 인자 와 반환값으로만 사용 가능
#### 전역 변수

- 스택 프레임에 독립적인 전역 변수
- 어느 곳에서나 접근 가능하므로 전역 변수 , 여러 메소드들이 사용하므로 공유 변수

-> 읽기 전용으로 값을 공유하는 전역 상수로만 사용하자
#### 멀티 스레드 / 멀티 프로세스

멀티 스레드 : 스택 영역을 스레드 개수만큼 분할해서 사용하는 것
멀티 프로세스 : 다수의 T 메모리( 스태틱,스택,힙)를 가지는 것

- 멀티 프로세스는 각 프로세스마다 T 메모리 있고,고유 -> 참조 불가능
- 멀티 스레드는 스택 영역만 분할, T 메모리 공유 -> 참조 가능
=> 멀티 스레드는 멀티 프로세스 대비 메모리를 적게 사용하는 구조
( 요청당 스레드가 요청당 프로세스보다 효율적인 이유 )

쓰기 가능한 전역 변수를 사용하면 스레드 안전성이 깨진다
-> Lock 거는 것 자체가 멀티 스레드의 장점을 버리는 것


---
tags:
  - 스프링
도서명: 스프링 입문을 위한 자바 객체 지향의 원리와 이해
저자명: 김종민
---
#### 객체 지향은 결국 인간 지향이다

구조적 프로그래밍 언어에서 함수가 나옴!
-> 코드를 논리적 단위로 구분 & 분할해 정복해나감
-> 그 후 파격적인 제안인 객체 지향이 나옴

우리가 주변에서 사물 인지하는 방식대로 프로그래밍 할 수 있지 않겠는가?
-> 객체 지향의 출발점

- 세상에 존재하는 모든 것은 사물, 객체다
- 각각의 사물은 고유하다
- 사물은 속성을 갖는다
- 사물은 행위를 한다

-> 그리고, 인간은 사물을 분류해서 이해한다

- 밤하늘에 반짝이는 사물들은 별이라고 분류한다

객체 지향 4대 특성

- 캡 - 캡슐화 : 정보 은닉
- 상 - 상속 : 재사용
- 추 - 추상화 : 모델링
- 다 - 다형성 : 사용 편의
#### 클래스 vs 객체 = 붕어빵틀 vs 붕어빵 ???

`클래스 객체명 = new 클래스()` - 납득 가능
`붕어빵틀 붕어빵 = new 붕어빵틀` - ?? 
-> 붕어빵틀은 결국 붕어빵을 만드는 Factory

- 객체와 클래스를 구분하는 간단한 방법? -> 나이를 물어보자
( 사람의 나이는 몇 살인가? 김연아의 나이는 몇 살인가? )

클래스는 결국, 분류에 대한 개념 <-> 객체는 실체
### 추상화 : 모델링

이집트 화가들은 사람의 사실적 모 습이 아니라
각 부분 특징을 잘 표현하도록 분해/결합해 벽화를 그렸다! 
=> 사람의 특징을 극대화해 추상적으로 그림

>추상 : 여러 가지 사물이나 개념에서 공통되는 특성이나 속성 따위를 추출해 파악하는 작용

=> 객체 지향의 추상화는 곧 모델링이다!

- 객체는 유일무이한 ( unique ) 사물이다
- 클래스는 같은 특성 지닌 여러 객체 총칭하는 집합 개념이다

결국 클래스가 먼저 나왔기에 객체가 나옴

사람 클래스가 사람의 모든 특성을 나열할 필요는??
-> 애플리케이션 경계를 구분하자

> 내가 만들고자 하는 애플리케이션은 어디에서 사용될 것인가?

추상화란 구체적인 것을 분해해서 관심 영역에 있는 특성만 가지고 재조합 하는 것
( 병원 애플리케이션에서 사람? -> 환자, 은행 애플리케이션에서 사람? -> 고객 )

- OOP 의 추상화는 모델링
- 클래스 설계에서 추상화 사용
- 클래스 설계 위해선 애플리케이션 경계부터 정해야 함
#### 추상화와 T 메모리

```java
public class Mouse {
	public String name;
	public int age;
	public int countOfTail;
	public void sing() {}
}
```

이 클래스 역시 T 메모리에서 static 영역에 배치
- 이름,속성 만 배치 - 값 X ( Mouse 객체의 속성 )
```java
Mouse mickey = new Mouse();
```
해당 코드는 3개의 명령문이 녹아 있다
1. Mouse mickey : Mouse 객체에 대한 참조 변수 mickey를 만듬
2. new Mouse() : Mouse 클래스 인스턴스를 하나 만들어 Heap 배치
3. 대입문 : Mouse 객체에 대한 주소(포인터) 참조 변수 mickey 에 할당
> 현실 세계의 은유 : 한 마리 쥐가 태어났으니, 그 이름을 mickey 라 한다.

`<main() 스택 프레임> : mickey = 100(포인터)`
`힙 프레임 : Mouse(name=null,age=0,countOfTail)`

```java
mickey = null;
```
아무도 Mouse 객체를 참조하지 않으면?
-> GC출격 - 쓰레기로 인지하여 수거
#### 클래스 멤버 vs 객체 멤버

미키마우스의 꼬리는? 제리의 꼬리는? 쥐의 꼬리는?
-> 전부 1개!

모든 객체가 같은 값을 가지는 경우 클래스 멤버(정적 멤버) 사용
- 사람 클래스 인구
- 고양이 클래스의 다리 개수
등등
##### 왜 main 은 정적 메소드여야 하는가?

T 메모리가 초기화 된 순간 객체는 하나도 존재하지 않으므로
객체 멤버 메소드 바로 실행 불가능!
##### 클래스 멤버 , 객체 속성은 왜 별도 초기화가 필요 없는가?

정수형 0, 부동소수점형 0.0, 논리형 false, 객체 null로 자동 초기화!
-> 공유 변수 초기화는 누가 초기화 해야 한다고 규정할 수 없음
-> 별도 초기화 하지 않아도 기본값으로 초기화

### 상속 : 재사용 + 확장

객체 지향에서 상속은 사실 재사용 과 확장으로 이해해야 한다
	    동물
   포유류           조류
고래   박쥐     참새   펭귄

=> 위는 상속 관계가 아니다!
( 동물은 포유류의 부모가 아님! 고래의 부모 역시 포유류 일 수 없음! )

객체지향에서 상속은 상위 클래스 특성을 하위 클래스에서 상속 + 필요한 특성을 추가할 수 있다는 의미

>객체 지향에서 상속은 슈퍼 클래스 - 서브 클래스로 이해하자
- 상위 클래스로 갈수록 추상화,일반화
- 하위 클래스로 갈수록 구체화,특수화

상속 관계에서는 `하위 클래스는 상위 클래스다.` 를 반드시 만족해야 한다.

아버지는 할아버지다?? 아들은 아버지다?? => ❌

포유류는 동물이다 -> 고래는 포유류다 -> 고래는 동물이다 => 🅾️??

자바에서는 애초에 `inheritance` 라는 용어가 존재하지 않는다
-> `extends` 가 존재 ( 무엇보다 객체 지향의 상속을 정확히 이해한 용어 )
#### 상속의 강력함

상속을 사용하더라도, 클래스명은 클래스답게 + 객체 참조 변수명은 객체답게 지어야 함을 잊지말자
```java
public class 조류 extends 동물 {
	조류() {
		myClass = "조류";
	}
}
조류 bird = new 조류();
```
bird 의 나이를 물을 수 있을까?
=> aBird , theBird 형태로 코딩은 가능

```java
동물 animal = new 동물();
포유류 mammalia = new 포유류();
animal.showMe();
mammalia.showMe();
```
mammalia 는 필요가 없다면, showMe 오버라이딩 할 필요 X
```java
동물 animal = new 동물();
동물 mamalia = new 포유류();
```
포유류를 동물로 표현하는게 문제가 있는가?
```java
동물[] animals = new 동물[];
animals[0] = new 동물();
animals[1] = new 포유류();
```
동물들 모이세요~ 와 같은 효과 기대 가능
#### 상속은 is-a 관계를 만족해야 한다?

펭귄 is a 동물?
-> 펭귄은 한 마리 동물이다
말은 OK??

펭귄은 클래스이다. 동물도 클래스이다.
-> 한 마리 동물은 클래스인가??

상위 클래스 - 하위 클래스로 변경하면?

하위 클래스는 하나의 상위 클래스이다??
하위 클래스는 분류/집단 상위 클래스는 분류/집단이다?? - 하나의 상위 클래스는 하나의 객체다
-> 하위 클래스는 하나의 객체다??!!!!

김연아는 한 명의 사람이다. - 한 명의 사람이 클래스는 아님
=> `is a kind of` 를 사용하자

- 펭귄 is a kind of 동물 -> 펭귄은 동물의 한 분류다
- 고래 is a kind of ehdanf -> 고래는 동물의 한 분류다

- 객체 지향의 상속은 상위 클래스의 특성을 재사용하는 것이다.
- 객체 지향의 상속은 상위 클래스의 특성을 확장하는 것이다.
- 객체 지향의 상속은 is a kind of 관계를 만족해야 한다.
#### 다중 상속과 자바

왜 자바는 다중 상속을 포기했는가?

EX ) 인어공주는 X 와 X 를 상속한다면?
-> 물고기 와 사람을 상속

인어공주가 수영을 한다면?
-> 물고기 처럼 수영? 사람 처럼 수영?
=> 이를 다중 상속의 다이아몬드 문제

C# 과 자바는 다중 상속을 포기했다.
-> 대신 인터페이스 도입!
#### 상속과 인터페이스

상속은 is a kind of
인터페이스는? 동일한 is a kind of??
-> 사실 상관없지만, 긴 세월 거치고 정제 & 발전하며 상속과 다르게 쓰는게 더 유용하다는 결론에 도달
=> 인터페이스는 `is able to`


`be able to("무엇을 할 수 있는)"` 형태로 interface 를 만들자

- 상위 클래스는 하위 클래스에 물려줄 특성이 많은게/적은게 좋을까? -> LSP 원칙
- 인터페이스는 구현 강제 메소드가 많은게/적은게 좋을까? -> ISP 원칙
##### 상속과 UML 표기법
![350](ttps://i.imgur.com/tNo0JFI.jpeg)
##### 상속과 T 메모리
```java
Penguin pororo = new Penguin();
```
Penguin,Animal 인스턴스가 같이 생성된다!

```java
Animal pingu = new Penguin();
```
사실상 pingu 는 자신이 펭귄이라는 사실을 기억 사실증에 걸린채 자신이 동물인것만 아는 인스턴스
### 다형성:사용 편의성

오버로딩 과 오버라이딩에 대한 설명은 생략

상위 클래스 타입의 객체 참조 변수 사용해도, 하위 클래스 오버라이딩 메소드가 호출
```java
Animal pingu = new Penguin();
```
Animal 의 메소드가 아닌 Penguin 의 메소드가 호출

오버로딩은 결국 함수명 하나를 가지고, 인자 목록만 다르게 하면 되므로 매우 편리!
( 자바 5에 나온 제네릭을 이용하여 하나의 함수만 구현해도 다수 구현한 효과 가능! )

오버라이딩은 하위 클래스가 재정의한 메소드 알아서 호출해주므로
형변환 or instanceof 연산자 써서 무엇인지 신경 쓸 필요 없다
### 캡슐화 : 정보 은닉

자바에서 정보 은닉은 private, default, protected, public 등으로 구현

UML 에서 `-` 는 private , `~`는 default, `#`는 protected, `+`는 public

public : 모두 접근 가능
protected : 상속 / 같은 패키지 내 클래스 접근 가능
default : 같은 패키지 내 클래스 접근 가능
private : 본인만 접근 가능
#### 참조 변수 복사
##### Call By Value
```java
int a = 10;
int b = a;

b = 20;

a // 10
b // 20
```

Call By Value 에 의해 값이 복사
두 개의 변수는 서로에게 영향을 주지 않는다
##### Call By Reference
```java
Animal ref_a = new Animal();
Animal ref_b = ref_a;

ref_a.age = 10;
ref_b.age = 20;

ref_a.age
ref_b.age
// => 둘다 20
```

Call By Reference 는 주소 복사

ref_a 와 ref_b 는 완전히 다른 변수이나
같은 값을 가지고 있고 값을 주소로서 활용





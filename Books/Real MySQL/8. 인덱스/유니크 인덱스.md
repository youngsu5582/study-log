

인덱스 이기 보다 제약 조건에 가까움
테이블,인덱스 에 같은 값 2개 이상 저장 불가능
( NULL 은 특정 값 아니므로, 2개 이상 저장 가능 )

- 인덱스 없이 유니크 제약만 설정할 방법 X

## 유니크 인덱스 - 세컨더리 인덱스 비교

사실 인덱스 구조상 아무런 차이 없다.

### 인덱스 읽기

유니크 인덱스가 빠르다고 생각하나, 사실이 아니다.
디스크 읽기가 아닌, CPU 에서 칼럼값 비교이므로 성능상 영향이 거의 없다.

유니크 하지 않은 세컨더리 인덱스는 중복된 값 허용
-> 읽은 레코드가 많아서 느린 것 ( 1건 읽을 때 0.1초, 2건 읽을 떄 0.2초 의 이치 )

### 인덱스 쓰기

레코드가 INSERT 되거나 인덱스 칼럼 값 변경시 쓰기 작업 필요
유니크 인덱스 키 값 쓸 때는 중복된 값이 있는지, 없는지 체크 해야 함
-> 유니크하지 않은 세컨더리 인덱스 쓰기보다 느리다.

중복된 값 체크 시에 읽기 잠금, 쓰기 할 때 쓰기 잠금 사용
-> 데드락이 빈번히 발생

> 인덱스 저장을 버퍼링 하기 위해 `체인지 버퍼` 가 사용
> 유니크 인덱스는 반드시 중복 체크 해야하므로 작업 자체 버퍼링 불가

### 유니크 인덱스 사용 시 주의사항

- 더 성능이 좋아진다고 생각하고, 불필요하게 생성하지 않는 것이 좋다.

- 같은 칼럼에 유니크, 일반 인덱스 중복 생성할 필요 없다. - 같은 역할

- 유니크, 프라이머리 인덱스 중복 생성할 필요 없다.

### 자식 테이블의 변경이 대기하는 경우

![350](https://i.imgur.com/CinfRtf.png)

1. 1번 커넥션에서 먼저 트랜잭션 시작
2. 부모 테이블에서 id가 2인 레코드에 UPDATE 실행
3. 2번 커넥션에서 자식 테이블의 외래키 칼럼 2로 변경 쿼리 실행
4. 부모 테이블 변경 작업 완료될 때 까지 대기
5. 1번 커넥션에서 ROLLBACK, COMMIT 으로 종료하면 대기 중이던 2번 작업 즉시 처리

=> 부모 테이블의 해당 레코드가 쓰기 잠금 걸려 있으면 `쓰기 잠금` 해제될 때 까지 대기

자식 테이블의 외래키가 아닌 칼럼의 변경은 외래키로 인한 잠금 확장이 발생하지 않는다.

### 부모 테이블의 변경 작업이 대기하는 경우

![350](https://i.imgur.com/eyqgPv1.png)

1. 1번 커넥션에서 부모 키 "1" 참조하는 tb_child(자식 테이블) 레코드 변경하면 `tb_child` 테이블 레코드에 대해 쓰기 잠금 획득
2. 2번 커넥션이 tb_parent(부모 테이블) 삭제 경우 tb_child 쓰기 잠금이 해제될 때 까지 대기한다.

정의된 외래키 특성 때문에 부모 레코드 삭제시 자식 레코드도 동시에 작동하는 식으로 작동하기 때문

자식 테이블에 레코드가 추가되는 경우, 참조키가 부모 테이블에 있는지 확인도 한다.
( 체크를 위해 읽기 잠금을 걸어야 함 )
-> 잠금이 다른 테이블로 확장되므로 쿼리 동시 처리에도 영향을 미침












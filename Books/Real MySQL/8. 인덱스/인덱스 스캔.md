## 인덱스 레인지 스캔

1. 인덱스에서 조건을 만족하는 값이 저장된 위치 찾음. - `인덱스 탐색`
2. 1번에서 탐색된 위치부터 필요 만큼 인덱스 차례대로 읽음 -  `인덱스 스캔`
3. 2번에서 읽어 들인 인덱스 키와 레코드 주소 이용해 레코드 저장된 페이지 가져오고, 최종 레코드 읽음
( 레코드를 읽는 건 랜덤 I/O 발생 )

쿼리가 필요로 하는 데이터에 따라 3번 과정이 필요 없을 수 있다.
-> ⭐️ 커버링 인덱스 ⭐️

### 커버링 인덱스

디스크 레코드 읽지 않아도 되므로, 랜덤 읽기가 상당히 줄어들고 + 성능은 매우 빨라짐

`SHOW STATUS LIKE 'Handler_%';
- Handler_read_first : 1번 단계 실행된 횟수
- Handler_read_next/prev : 2번 단계 실행된 함수

## 인덱스 풀 스캔

인덱스 처음부터 끝까지 모두 읽는 방식
데이터 레코드까지 읽어야 한다면 절대 이 방식으로 처리 X
( 테이블 풀 스캔보단 효율적- 적은 디스크 I/O )

> 특별한 방식 없이 "인덱스 사용한다" 는 `인덱스 레인지 스캔` or `루스 인덱스 스캔` 을 사용하는 것
> 인덱스를 이용하나 효율적인 방식이 아니며, 인덱스 생성 목적이 아님

##  루스 인덱스 스캔

MySQL 8.0 버전 부터 다른 사용 DBMS 처럼 최적화 조금씩 지원하기 시작
느슨하게 인덱스를 읽는 것

- GROUP BY, MAX, MIN 대해 최적화 할때 사용
- 중간에 필요하지 않은 값 SKIP

```sql
SELECT dept_no, MIN(emp_no)
FROM dept_emp
WHERE dep_no BETWEEN 'd0002' AND 'd004'
GROUP BY dept_no;
```

( dept_no,emp_no ) 와 같이 인덱스가 정렬되어 있다.

-> dept_no 그룹별로 맨 처음 emp_no 만 읽으면 된다.

## 인덱스 스킵 스캔

> 인덱스의 핵심 값은 정렬되어 있다.
> -> 인덱스를 구성하는 칼럼의 순서는 매우 중요하다.

기존에는 (gender,birth_date) 와 같은 인덱스가 있다면?

```sql
SELECT * FROM employees WHERE birth_date >= '1965-02-01';
-> 인덱스를 사용할 수 없었음 
SELECT * FROM employees WHERE gender='M' AND birth_date>='1965-02-01';
-> 인덱스 사용
```

8.0 버전부터는 `gender` 칼럼 건너뛰고, `birth_date` 칼럼만으로 검색해주는 인덱스 스킵 스캔 최적화 기능이 도입되긴 했다.
기존은 `INDEX FULL SCAN` , 적용 후 `INDEX RANGE SCAN`

이와 같은 단점 존재

- WHERE 조건절에 조건이 없는 인덱스 선행 칼럼의 유니크한 값 개수가 적어야 함

유니크 값 개수가 많다면, 인덱스 스캔해야 할 시작 지점 검색 작업이 많이 필요해짐

- 쿼리가 인덱스 존재하는 칼럼만으로 처리 가능해야 함 ( 커버링 인덱스 )

```sql
SELECT *
FROM employees
WHERE birth_date >= '1965-02-01';
```

모든 칼럼을 조회 ( 인덱스 포함된 칼럼 이외 나머지 칼럼도 필요 )
-> 풀 테이블 스캔으로 실행 계획 술비된다.

## 다중 칼럼 인덱스

실제 서비스상 2개 이상 칼럼 포함하는 인덱스 더 많이 사용된다.

![300](https://i.imgur.com/13Mad2H.jpeg)

루트 노드와 리프 노드는 항상 존재한다. ( 브랜치 노드는 없는 경우도 존재 )
⭐️⭐️ 인덱스 두 번째 칼럼은 첫 번째 칼럼에 의존되어 정렬!

2..3..4 늘어날수록 더욱 민감해진다.
-> 순서는 상당히 중요하고, 신중히 결정을 해야 한다.

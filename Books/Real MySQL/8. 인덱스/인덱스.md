
데이터의 저장 ( INSERT, UPDATE, DELETE ) 성능 희생하고, 읽기 속도를 높인다.
=> 어디까지 희생할 수 있는지, 얼마나 더 빠르게 만들어야 하는지 결정해야 한다

- 프라이머리 키 : 대표하는 칼럼 값으로 만든 인덱스 - 레코드 식별 기준, NULL 허용 X, 중복 허용 X
- 보조 키 : 프라이머리 키 제외한 인덱스 ( 유니크 인덱스는 프라이머리 키와 유사해 대체 키라 불리기도 함 )

### B-Tree 

일반적으로 사용되는 알고리즘, 칼럼 값 변형하지 않고 원래 값 이용해 인덱싱
- R-Treee : 위치 기반 검색 지원 위한 알고리즘, 응용 알고리즘
### Hash 

칼럼 값으로 해시값을 인덱싱, 매우 빠른 검색 지원
값을 변경하므로, Prefix 일치나, 값 일부만 검색하는게 불가능 
( 메모리 기반 DB 에서 주로 사용 )

---

유니크 인덱스는 동등 조건으로 검색할 때 <span style="color:rgb(255, 0, 0)">항상 1개만 찾아도 된다는 것</span>을 옵티마이저에게 알려주는 것이다!

## B-Tree

Balanced-Tree

칼럼 원래 값을 변형시키지 않고, 인덱스 구조체 내 항상 정렬된 상태 유지

최상위 하나의 `루트 노드` 존재
루트 노드도 아니고, 리프 노드도 아닌 중간 노드 `브랜치 노드`
가장 하위에 있는 `리프 노드`

![400](https://i.imgur.com/V07YawD.jpeg)

레코드는 정렬되어 있지 않고, 임의 순서로 저장되어 있다.
( INSERT 만 하면 동일하나, 삭제되어 빈 공간 생길 시, 재활용하도록 설계되어 있다. )

> InnoDB 는 디폴트로 클러스터링 테이블이 생성된다.

#### MyISAM 
레코드가 테이블에 INSERT 된 순번 or 데이터 파일 내 위치 이다.
데이터를 바로 찾아갈 수 있다.
#### InnoDB

![500](https://i.imgur.com/A30L9zp.jpeg)

인덱스를 통해 데이터를 읽을 때 바로 찾아가지 못한다.
인덱스에 저장되어 있는 프라이머리 키 값 이용해 -> 다시 읽어야 한다.

### 인덱스 키 추가

리프 노드가 꽉 차서 더 저장할 수 없을 시, 리프 노드가 분리되어야 한다.
-> 상위 브랜치 노드까지 처리 범위 넓어짐
( 상대적으로 쓰기 작업에 비용이 많이 드는 것으로 알려짐 )


인덱스 추가가 `INSERT` , `UPDATE` 에 영향을 얼마나 미치는 지는
테이블 칼럼 수, 칼럼 크기, 인덱스 칼럼 특성 등을 확인해야 한다.

대략, 레코드를 추가하는 작업 비용은 `1` , 인덱스에 키를 추가하는 작업은 `1.5` 로 산정하자.
( 즉, 테이블에 인덱스가 3개 있으면? -> 1 + 3`*`1.5 = 5.5 )

이 비용의 대부분은 메모리와 CPU 에서 처리하는 시간이 아닌, 디스크에서 인덱스 페이지를 읽고 쓰기 해서 걸리는 시간이다.

### 인덱스 키 삭제

해당 키 값이 저장된 리프 노드를 찾아서, 삭제 마크를 한다.
( 마킹된 인덱스 키 공간은 방치 or 재활용 )

이 역시, 디스크 쓰기가 필요하므로 디스크 I / O 가 필요한 작업이다.

### 인덱스 변경

키 값에 따라 리프 노드의 위치가 결정되므로, 단순 키 값만 변경하는게 불가능하다.
기존 인덱스 키 값 삭제 -> 새로운 인덱스 키 값 추가 작업

### 인덱스 검색

이를 위해 인덱스를 구축한 것이다.
B-Tree 루트 노드부터 시작 -> 브랜치 노드 거쳐 -> 최종 리프 노드 까지 이동
-> 인덱스 트리 탐색


> 트리 탐색은 SELECT 만 사용하는게 아닌, UPDATE / DELETE 처리에도 사용


100% 일치 또는 값의 앞 부분 일치하는 경우에도 사용 가능
( 키 값의 뒷부분만 검색하는 용도로는 사용 불가능 )

키 값에 변형이 가해진 후에는 `B-Tree` 의 빠른 검색 기능을 사용할 수 없다.

UPDATE,DELETE 를 할 때 인덱스가 없으면 불필요하게 많은 레코드를 잠근다.
( 인덱스를 잠근 후, 테이블 레코드를 잠그는 방식으므로 )

### 인덱스 키 값의 크기

디스크에 데이터 저장하는 가장 기본 단위 : `Page` or `Block`
( 페이지는 버퍼 풀에서 데이터 버퍼링 하는 기본 단위 )

B-Tree 가 가지는 자식 노드 개수는 가변적인 구조
-> 인덱스 페이지 크기와 키 값의 크기로 결정된다.

> 16KB 인덱스 페이지라면? ( 인덱스 키 값이 16바이트, 자식 노드 주소 값이 12 바이트라 가정 )
> 16 *  1024 / ( 16 + 12 ) = 585
> 자식 노드를 585개 가질 수 있는 B-Tree
> 키 값이 32바이트라면?
> 16 * 1024 / ( 32 + 12 ) = 372

인덱스를 구성하는 키 값 크기가 커지면, 디스크 읽는 횟수가 늘어나며 느려진다는 것을 의미한다.

인덱스 키 값 길이가 길어지면, 전체적 인덱스 크기가 커진다는 것이다. - 버퍼 풀, 키 캐시 영역은 크기 제한적이므로 비효율적

#### B-Tree 깊이

깊이는 MySQL 에서 값을 검색할 때, 몇 번이나 랜덤하게 디스크를 읽어야 하는지와 직결된다.
-> 키 값 크기가 커질 수록, 담는 키 값의 개수가 적어지고 + 깊이가 깊어져서 더 많이 읽기가 필요해진다.

=> 가능하면 작게 만드는 것이 좋다! ( 깊이가 5단계 이상 깊어지는 경우는 흔치 않다. )

### 선택도(기수성)

선택도(Selectivity)와 기수성(Cardinality)은 거의 같은 의미로 사용된다.
-> 선택도가 높을수록 검색 대상이 줄어들기에 빠르게 처리된다.

> 정렬,Grouping 같은 작업 위해선 인덱스 만드는 게 훨씬 좋을 순 있음. - 선택도가 떨어져도

```sql
select *
from tb_test
where country='KOREA' AND city ='SEOUL';
```

### CASE

country 에만 인덱스가 걸려있다.
인덱스된 칼럼에 대해 전체 레코드 건수 or 유니크한 값의 개수를 가지고 있음
> 전체 레코드 개수 / 유니크한 개수 = 인덱스가 검사해야 하는 개수


- country 칼럼의 유니크 값이 10개 일때 ( 테이블에 10개 국가의 도시 정보 저장 )
`country='KOREA'` 로 검색시 1000건이 일치한다. -> 1000건 중 999건이 불필요하게 읽은것

- country 칼럼의 유니크 값이 1000개 일때 ( 테이블에 1000개 국가의 도시 정보 저장 )
`country=KOREA` 로 검색시 10건이 일치한다. -> 10건 중 1건이 불필요하게 읽은 것


=> 두 쿼리가 처리되기 위해 MySQL 서버가 수행한 작업 내용은 매우 차이가 난다.

---

- 인덱스를 통해 레코드를 읽는게 일반적인 레코드보다 4~5배 비용이 많이 든다고 예측
- 전체 테이블 레코드의 20~25% 넘어가면 인덱스를 이용하지 않고 필터링 하는 방식이 효율적
( 강제로, 인덱스를 태우게 힌트를 줘도 의미가 없다. )
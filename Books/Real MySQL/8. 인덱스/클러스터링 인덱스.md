
## 클러스터링 인덱스

레코드를 비슷한 것 끼리 묶어서 저장하는 형태로 구현
-> 비슷한 값은 동시에 조회하는 경우가 많음

- InnoDB 에서만 엔진 지원

테이블의 프라이머리 키에 대해서만 적용

⭐️ 프라이머리 키 값에 의해 레코드의 저장 위치가 결정된다! ⭐️

-> 프라이머리 키 기반 검색이 매우 빠름
-> 레코드 저장, 키 변경이 상대적으로 느려짐

자체가 하나의 거대한 인덱스 구조로 관리

1. 프라이머리 키가 있으면 기본적으로 프라이머리 키 `클러스터링 키`로 선택
2. NOT NULL 옵션의 유니크 인덱스 중 첫 번째 인덱스를 선택
3. 자동으로 유니크한 값 가지도록 증가되는 칼럼 내부적 추가후 선택 ( 쿼리 문장에 명시적 사용 불가능 )

## 세컨더리 인덱스에 미치는 영향

> MyISAM, MEMORY 테이블은 처음 저장된 공간에서 이동하지 않는다.
> 저장된 주소가 내부적인 레코드 아이디(ROWID) 역할
> 프라이머리 키, 세컨더리 인덱스는 구조적 차이 X


InnoDB 에서는 이가 불가능하다.
클러스터링 키 값 변경때마다 데이터 레코드 주소 변경 -> 모든 인덱스에 저장된 주소값 변경

=> 오버헤드 제거 위해 레코드가 저장된 주소가 아닌, 프라이머리 키 값을 저장하게 구현 

## 장점
- 프라이머리 키로 검색 시 처리 성능이 매우 빠름
- 테이블 모든 세컨더리 인덱스가 프라이머리 키 가지고 있기 때문에 인덱스만으로 처리되는 경우가 많음

## 단점
- 테이블의 모든 세컨더리 인덱스가 클러스터링 키를 가지므로 인덱스 크기가 커짐
- 세컨더리 인덱스 통해 검색할 때 프라이머리 키로 다시 한번 검색해야 하므로 처리 성능이 느림
- INSERT 할 때 프라이머리 키에 의해 레코드 저장 위치 결정되므로 처리 성능 느림
- 프라이머리 키 변경 때 레코드 DELETE 하고, INSERT 하는 작업 필요하므로 처리 성능 느림

=> OLTP 에선 쓰기 읽기 비율이 2:8, 1:9 정도이므로 읽기를 빠르게 유지하는게 좋은 선택의 요소

## 주의사항

### 인덱스 키의 크기

프라이머리 키가 커지면, 세컨더리 인덱스도 자동으로 크기가 커진다.

프라이머리 키 크기가 10바이트라면?
-> 레코드당 증가하는 인덱스 크기는 10B `*` 5 = 50B, 100만 건 저장 시 50B `*` 1,000,000 = 47MB

프라이머리 키 크기가 50바이트라면?
-> 레코드당 증가하는 인덱스 크기는 50B * = 250B, 100만 건 저장 시 250B `*` 1,000,000 = 238MB
-> 1,000 만건이 되면 1.9GB 증가!!

### 프라이머리 키는 AUTO_INCREMENT 보다 업무적 칼럼으로 생성 (가능시)

업무적으로 해당 레코드를 대표할 수 있다면, 칼럼을 프라이머리 키로 설정
-> 검색에서 상당히 빈번하게 사용되는게 일반적

### 프라이머리 키 반드시 명시

자동 추가된 칼럼은 사용자에게 안 보이므로, 사용 불가능
-> 사용자가 사용할 수 있는 값으로 설정하자.



잠금은 스토리지 엔진 레벨과 MySQL 엔진 레벨로 나눌 수 있다.
( MySQL 엔진은 MySQL 서버에서 스토리지 엔진 제외한 나머지 부분 )

- MySQL 엔진 레벨 잠금은 모든 스토리지에 영향을 미친다.
- 스토리지 엔진 레벨의 잠근은 스토리지 엔진 간 상호 영향 미치지 않는다.

## 글로벌 락

`FLUSH TABLES WITH READ LOCK` 명령으로 획득 가능하다.

한 세션에서 글로벌 락 획득시
다른 세션들은 `SELECT` 제외한 대부분 DDL 문장이나 DML 문장 실행 경우 글로벌 락이 해제될 때까지 해당 문장이 대기 상태

> mysqldump 같은 백업 프로그램이 명령을 내부적으로 실행할 수 있다.
> MySQL 서버에 어떤 잠금을 걸게 되는지 확인해보는 것도 좋다.

InnoDB 는 트랜잭션을 지원하므로 일관된 데이터 상태를 위해 모든 데이터 변경 작업을 멈출 필요는 없다.

### 백업 락

MySQL 8.0부턴 백업 툴들의 안정적 실행 위해 백업 락 도입

```sql
LOCK INSTANCE FOR BACKUP;

UNLOCK INSTANCE;
```

- 데이터베이스 및 테이블 등 모든 객체 생성 및 변경, 삭제
- REPAIR TABLE과 OPTIMIZE TABLE 명령
- 사용자 관리 및 비밀번호 변경

백업 락은 일반적인 테이블의 데이터 변경만 허용

## 테이블 락

개별 테이블 단위 설정되는 잠금
명시적으로 `LOCK TABLES table_name [READ|WRITE]` 를 통해 획득 가능하다.
( `UNLOCK TABLES` 명령으로 잠금 반납 가능 )

InnoDB 에서는 데이터 변경 ( DML ) 에서는 무시되고 스키마 변경하는 쿼리 ( DDL ) 경우에만 영향을 미친다.

## 네임드 락

`GET_LOCK` 함수 이용해 임의 문자열에 대한 잠금 설정가능하다.
( 잠금의 대상이 테이블, 레코드 또는 `AUTO_INCREMENT` 같은 DB 객체가 아님 )

DB 하나에 여러 대의 서버가 접속해 발생화는 동기화를 해결하기 위해 사용

`SELECT GET_LOCK('mylock',2);`

- 문자열에 대해 잠금 획득
- 이미 잠금 사용 중이라면 2초 동안만 대기 ( 2초 후 자동 잠금 해제 )

`SELECT IS_FREE_LOCK('mylock');`

- 문자열에 대해 잠금 설정돼 있는지 확인

`SELECT RELEASE_LOCK('mylock');`

- 획득했던 잠금 해제

=> 정상적 락 획득 or 해제시 1, 아니면 NULL이나 0을 반환한다.

네임드 락 경우 많은 레코드 변경하는 쿼리 ( 데드락을 유발하는 ) 를 처리하는데 사용될 수 있다.

## 메타데이터 락

불필요하다 생각해 생략한다.

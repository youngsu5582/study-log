
InnoDB 스토리지 엔진은 스토리지 엔진 내부에서 레코드 기반 잠금 방식 탑재
( MyISAM 보다 훨씬 뛰어난 동시성 처리 )

> 예전에는 이원화된 잠금 처리 탓에 잠금에 대한 정보는 MySQL 명령어로 접근하기 상당히 까다로웠다.
> 최근 버전에는 InnoDB의 트랜잭션과 작믐, 잠금 대기 중인 트랜잭션 목록 조회하는 방법이 도입됐다.
> `information_schema` DB에서 `INNODB_TRX`, `INNODB_LOCKS`, `INNODB_LOCK_WAITS` 테이블 조인해서 조회 가능하다.
> `SELECT * FROM sys.innodb_lock_waits; - 현재는 이렇게도 가능하다.

## 레코드 락

레코드 기반의 잠금 기능 제공, 잠금 정보가 상당히 작은 공간으로 관리한다.


레코드 자체만을 잠그는 것 ( Record lock, Record only lock )
InnoDB 스토리지 엔진은 레코드 자체가 아니라, 인덱스 레코드를 잠그는 것 ⭐️⭐️

인덱스가 하나도 없는 테이블이라도 내부적 자동 생성된 클러스터 인덱스를 이용해 잠금을 설정한다.
( 보조 인덱스를 이용한 변경 작업은 이어서 설명하는 넥스트 키 락 또는 갭 락 사용한다. )
( 프라이머리 키 or 유니크 인덱스에 의한 변경 작업에선 갭에 대해 잠그지 않고 레코드 자체에 대해 락을 건다. )

### 갭 락

레코드 자체가 아니라 레코드와 바로 인접한 레코드 사이 간격만을 잠그는 것
-> 레코드와 레코드 사이 간격에 새로운 레코드 생성되는 것을 제어

### 넥스트 키 락

레코드 락과 갭 락을 합쳐 놓은 형태
STATEMENT 포맷 바이너리 로그 사용하는 MySQL 서버에서 `REPEATABLE READ` 격리 수준을 사용해야 한다.

바이너리 로그에 기록되는 쿼리가 레플리카 서버에서 실행될 때 
소스 서버에서 만들어 낸 결과와 동일한 결과를 만들어내도록 보장하는 것이 주목적이다.

> 5.5 버전까지는 ROW 포맷의 바이너리 로그가 도입된 지 오래되지 않아서 그다지 널리 사용되지 않았다.
> STATEMENT 포맷의 바이너리 로그가 가지는 단점을 많이 해결해줄 수 있기 때문에 
> MySQL 8.0 에선 ROW 포맷의 바이너리 로그가 기본 설정으로 변경 ( 바로 그 레코드에 적용 )

-> 가능하다면 바이너리 로그 포맷을 ROW 형태로 바꿔 넥스트 키 락이나 갭 락을 줄이는 것이 좋다.

`SELECT ... WHERE ...` 범위 조회 이후, 동일 트랜잭션 내 동일 쿼리 재실행 때 결과가 변화는걸 막는다. ( 팬텀 현상 )
-> 즉, `REPETABLE READ` 격리수준을 사용한다면 필요함

`STATEMENT` 포맷을 쓰는 경우 마스트 - 래플리카에서 동일 쿼리 실행할 때 결과 달라지지 않게 하기 위해 범위 내 데이터 보호

## 자동 증가 락

테이블 수준의 잠금

자동 증가하는 숫자 값을 추출하기 위해 `AUTO_INCREMENT` 칼럼이 사용된 테이블에
동시에 여러 레코드가 INSERT 되는 경우, 레코드는 중복되지 않고 저장된 순서대로 증가하는 일련번호 값을 가져야 한다.

- INSERT, REPLCATE 같은 새로운 레코드 저장하는 쿼리에서만 필요
- UPDATE, DELETE 등의 쿼리에선 걸리지 않음

트랜잭션과 관계없이 가져오는 순간만 락이 걸렸다가 즉시 해제
( 동시 실행 시, 나머지 쿼리는 AUTO_INCREMENT 락을 기다림 )

위 자동 증가 락은 5.0 이하 버전에서 사용되던 방식
-> 5.1 이상부터는 `innodb_autoinc_lock_mode` 시스템 변수를 이용해 락 작동 방식 변경 가능

- `innodb_autoinc_lock_mode=2`

InnoDB 스토리지 엔진은 절대 자동 증가 락을 걸지 않고 경량화된 레치(뮤택스) 사용
하나의 INSERT 문장이더라도 연속된 자동 증가 값 보장하지 않는다.

인터리빙 모드 ( Interleaved mode ) 이라고 함

`INSERT ... SELECT` 와 같은 대량 INSERT 문장 실행 중에도 다른 커넥션에서도 INSERT 를 수행할 수 있으므로 동시 처리 성능이 높아진다.

> STATEMENT 포맷 바이너리 로그일 시 소스 서버와 래플리카 서버 자동 증가 값이 달라질 수 있다.

> MYSQL 8.0 부턴 기본값이 2이다. 8.0에서 ROW 포맷이 아닌 STATEMENT 포맷이라면 1로 변경해서 사용할 것 권장

## 인덱스와 잠금

InnoDB 의 잠금은 레코드를 잠그는 것이 아닌 인덱스를 잠그는 방식으로 처리

```sql
select count(*) from employees where first_name = 'Georgi';
-> 253

select count(*) from employees where first_name = 'Georgi' AND last_name='Klassen';
-> 1

UPDATE employees SET hire_date=NOW() WHERE first_name='Georgi' AND last_name='Klassen';
```

first_name 에 해당하는 인덱스만 있다면?
-> 253개의 레코드가 모두 잠긴다.

### 레코드 수준 잠금 확인 및 해제

테이블의 레코드 수준 잠금은 테이블 수준의 잠금보다 조금 더 복잡하다.
	

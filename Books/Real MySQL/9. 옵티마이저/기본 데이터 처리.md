
## 풀 테이블 스캔

인덱스를 사용하지 않고 테이블 데이터를 처음부터 끝까지 읽어 요청된 작업 처리

- 테이블 레코드 건수가 너무 작아서 인덱스를 통해 읽는 것보다 풀 테이블 스캔 하는 편이 더 빠른 경우 ( 테이블이 페이지 1개로 구성된 )
- WHERE 절이나 ON 절에 인덱스를 이용할 수 있는 적절한 조건이 없는 경우
- 인덱스 레인지 스캔을 사용할 수 있는 쿼리라 하더라도 옵티마이저가 판단한 조건 일치 레코드 건수가 너무 많은 경우 ( B-Tree 샘플링해서 조사한 통계 정보 기준 )

특정 테이블의 연속된 데이터가 읽히면 백그라운드 스레드가 `리드 어헤드` 작업 자동으로 시작

### 리드 어헤드

앞으로 필요해지리라 예측해서 요청이 오기 전 디스크에서 읽어 InnoDB 의 버퍼 풀에 가져다 두는 것
몇 개의 데이터 페이지는 포그라운드 스레드가 페이지 읽기 실행
-> 특정 시점부터 읽기 작업 백그라운드로 넘긴다.
한번에 최대 64개 데이터 페이지까지 읽어서 버퍼 풀에 저장


- `innodb_read_ahead_threshold` : 언제 리드 어헤드를 시작할지 임계값

---

```sql
SELECT COUNT(*) FROM employees;
```

위와 같은 쿼리는 풀 인덱스 스캔 ( 건수만 필요한 쿼리이므로 용량 작은 인덱스를 선택 )

## ORDER BY 처리
쿼리에서 정렬은 필수적으로 사용된다.

### 인덱스 이용

- 장점 : WRITE 연산 시 인덱스가 정렬 되므로, 순서대로 읽기만 하면 되어 매우 빠르다.
- 단점 : WRITE 연산 시 부가적인 인덱스 추가/삭제 작업이 필요해서 느리다.

### Filesort 이용

- 장점 : 인덱스를 생성하지 않아도 되어 인덱스 장점이 곧 장점, 정렬해야 할 레코드가 많지 않으면 메모리 단에서 Filesort 가 처리되므로 충분히 빠르다.
- 단점 : 쿼리 실행 시 처리되므로 레코드 대상 건수 많아질수록 쿼리 응답 속도 느려짐

사실상 모든 정렬을 인덱스를 이용하도록 튜닝은 어렵다.

- 정렬 기준이 너무 많아 요건별로 모든 인덱스 생성이 불가능한 경우
- GROUP BY 결과 또는 DISTINCT 결과를 정렬해야 하는 경우
- 임시 테이블 결과를 다시 정렬해야 하는 경우
- 랜덤하게 결과 레코드 가져와야 하는 경우

## 소트 버퍼

정렬을 수행하기 위해 별도 할당받는 메모리 공간
레코드 크기에 따라 가변적 증가는 하나, 최대 버퍼 공간은 지정 가능하다. ( `sort_buffer_size` )
쿼리 실행이 완료되면 즉시 시스템으로 반납된다.

### 정렬해야 하는 레코드 건수가 할당 공간보다 크다면?

정렬 레코드를 여러 조각으로 나눠서 처리 -> 임시 저장 위해 디스크 사용
버퍼 크기만큼 정렬된 레코드를 다시 병합하며 정렬 수행해야 함
=> 멀티 머지

---

- 일반적인 트랜잭션 처리용 MySQL 서버의 소트 버퍼 크기는 56KB, 1MB 미만이 적절하다 생각

소트 버퍼는 세션(로컬) 메모리 영역
-> 커넥션이 많을수록, 정렬 작업이 많을수록 소비되는 메모리 공간이 커져간다.

> 크게 설정 시 디스크 읽기와 쓰기 사용량은 줄일 수 있다.
> -> 디스크 I/O 성능이 낮은 장비라면 크게 설정하는게 도움이 된다.



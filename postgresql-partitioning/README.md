# PostgreSQL 파티셔닝 성능 비교 테스트

이 프로젝트는 PostgreSQL의 테이블 파티셔닝 기능이 대용량 데이터 처리 시 성능에 미치는 영향을 비교 분석하기 위한 테스트 스크립트 모음입니다.

두 가지 시나리오를 통해 성능을 비교합니다:
1.  **단일 테이블**: 약 2억 4천만 건의 데이터를 가진 거대한 단일 테이블
2.  **파티션된 테이블**: 동일한 데이터를 월별로 분리하여 저장한 파티션된 테이블

## 테스트 환경 요구사항

-   Docker & Docker Compose
-   `psql` (PostgreSQL 클라이언트)

## 테스트 진행 방법

### 1. 데이터베이스 실행

프로젝트 루트 디렉터리에서 아래 명령어를 실행하여 테스트에 사용할 PostgreSQL 데이터베이스를 실행합니다.

```bash
docker-compose up -d
```

-   **Host**: `localhost`
-   **Port**: `5432`
-   **Username**: `user`
-   **Password**: `password`
-   **Database**: `mydatabase`

### 2. 데이터베이스 접속

`psql`을 사용하여 실행된 데이터베이스에 접속합니다.

```bash
psql -h localhost -p 5432 -U user -d mydatabase
```

비밀번호(`password`)를 입력하라는 메시지가 나타나면 입력합니다.

### 3. 테스트 스크립트 실행

`psql` 클라이언트 내에서 아래 스크립트들을 순서대로 실행합니다. 각 스크립트는 데이터 생성에 수십 분 이상 소요될 수 있습니다.

**1) 단일 테이블 생성 및 데이터 삽입**

```sql
\i 01_create_single_table.sql
```

**2) 파티션된 테이블 생성 및 데이터 삽입**

```sql
\i 02_create_partitioned_table.sql
```

### 4. 성능 비교 테스트 실행

데이터 생성이 모두 완료되면, 아래 스크립트를 실행하여 두 테이블 간의 성능 차이를 확인합니다.

```sql
\i 03_performance_tests.sql
```

이 스크립트는 `EXPLAIN (ANALYZE, BUFFERS)` 명령을 사용하여 각 시나리오(조회, 삭제, 전체 스캔 등)에 대한 실제 실행 계획과 소요 시간, 사용된 버퍼 등을 상세하게 출력합니다.

### 5. 결과 분석

`03_performance_tests.sql`의 실행 결과를 통해 아래와 같은 관점에서 성능 차이를 분석할 수 있습니다.

-   **특정 기간 조회**: 파티션된 테이블이 `Partition Pruning`을 통해 훨씬 빠른 응답 속도를 보이는지 확인합니다. `Execution time`을 비교해 보세요.
-   **오래된 데이터 삭제**: 단일 테이블의 `DELETE`와 파티션 테이블의 `DROP PARTITION` 간의 개념적 차이와 예상되는 성능 차이를 확인합니다. (테스트 스크립트는 실제 `DELETE`를 수행하지 않고 `EXPLAIN`만 보여줍니다.)
-   **전체 테이블 스캔**: 두 테이블의 전체 스캔 속도를 비교합니다. 파티션된 테이블의 경우 병렬 처리(Parallel Scan)가 더 효율적으로 동작할 수 있습니다.
-   **유지보수**: 인덱스 재구성과 같은 유지보수 작업을 전체 테이블에 수행하는 것과 특정 파티션에만 수행하는 것의 차이를 이론적으로 비교합니다.

### 6. 테스트 환경 종료

테스트가 완료되면 아래 명령어로 데이터베이스 컨테이너를 중지 및 삭제할 수 있습니다.

```bash
docker-compose down
```

볼륨을 함께 삭제하여 모든 데이터를 초기화하려면 아래 명령어를 사용하세요.

```bash
docker-compose down -v
```
